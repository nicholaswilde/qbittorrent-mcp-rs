use serde_json::Value;
use std::io::{BufRead, BufReader, Write};
use std::process::{Command, Stdio};

#[test]
fn test_stdio_interaction() {
    // Locate the binary generated by cargo
    let bin_path = env!("CARGO_BIN_EXE_qbittorrent-mcp-rs");

    let mut child = Command::new(bin_path)
        .arg("--server-mode")
        .arg("stdio")
        .arg("--qbittorrent-host")
        .arg("localhost")
        .arg("--qbittorrent-port")
        .arg("8080")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .expect("Failed to spawn process");

    let mut stdin = child.stdin.take().expect("Failed to open stdin");
    let stdout = child.stdout.take().expect("Failed to open stdout");
    let stderr = child.stderr.take().expect("Failed to open stderr");
    let mut reader = BufReader::new(stdout);

    // Spawn a thread to print stderr
    std::thread::spawn(move || {
        let stderr_reader = BufReader::new(stderr);
        for l in stderr_reader.lines().map_while(Result::ok) {
            eprintln!("[SERVER STDERR] {}", l);
        }
    });

    // 1. Initialize
    let init_req = r#"{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"implementation":{"name":"test-client","version":"1.0.0"}}}"#;
    writeln!(stdin, "{}", init_req).expect("Failed to write init req");

    let mut line = String::new();
    reader
        .read_line(&mut line)
        .expect("Failed to read init response");
    if line.is_empty() {
        panic!("Read empty line for init response");
    }
    let resp: Value = serde_json::from_str(&line).expect("Failed to parse init response");
    assert!(
        resp.get("result").is_some(),
        "Init response should have result. Got: {:?}",
        resp
    );

    // 1.5 Send initialized notification
    let initialized_notif = r#"{"jsonrpc":"2.0","method":"notifications/initialized","params":{}}"#;
    writeln!(stdin, "{}", initialized_notif).expect("Failed to write initialized notification");

    // Give server a tiny moment to process the notification
    std::thread::sleep(std::time::Duration::from_millis(100));

    // 2. List Tools
    let list_req = r#"{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}"#;
    writeln!(stdin, "{}", list_req).expect("Failed to write list req");

    line.clear();
    reader
        .read_line(&mut line)
        .expect("Failed to read list response");
    let resp: Value = serde_json::from_str(&line).expect("Failed to parse list response");
    assert!(
        resp.get("result").is_some(),
        "List tools response should have result. Got: {:?}",
        resp
    );

    let result = resp.get("result").unwrap();
    let tools = result.get("tools").unwrap().as_array().unwrap();
    // Default is non-lazy, so we expect many tools
    assert!(
        tools.len() > 2,
        "Should have multiple tools in non-lazy mode"
    );

    // 3. Call Tool (list_torrents)
    // This might fail connection-wise if no qbit is running, but should return JSON-RPC response
    let call_req = r#"{"jsonrpc":"2.0","id":3,"method":"tools/call","params":{"name":"list_torrents","arguments":{}}}"#;
    writeln!(stdin, "{}", call_req).expect("Failed to write call req");

    line.clear();
    reader
        .read_line(&mut line)
        .expect("Failed to read call response");
    let resp: Value = serde_json::from_str(&line).expect("Failed to parse call response");

    // Either success (result) or error (error)
    assert!(
        resp.get("result").is_some() || resp.get("error").is_some(),
        "Call response should have result or error. Got: {:?}",
        resp
    );

    // Clean up
    drop(stdin); // Close stdin to signal exit
    let _ = child.wait().expect("Failed to wait on child");
}
