/home/nicholas/git/nicholaswilde/qbittorrent-mcp-rs/src/client.rs:
    1|       |use anyhow::{Result, anyhow};
    2|       |use reqwest::Client;
    3|       |
    4|       |#[derive(Clone)]
    5|       |pub struct QBitClient {
    6|       |    http: Client,
    7|       |    base_url: String,
    8|       |    username: Option<String>,
    9|       |    password: Option<String>,
   10|       |}
   11|       |
   12|       |impl QBitClient {
   13|     18|    pub fn new(
   14|     18|        base_url: impl Into<String>,
   15|     18|        username: impl Into<String>,
   16|     18|        password: impl Into<String>,
   17|     18|        no_verify_ssl: bool,
   18|     18|    ) -> Self {
   19|       |        // Enable cookie store for session management (SID)
   20|     18|        let http = Client::builder()
   21|     18|            .cookie_store(true)
   22|     18|            .danger_accept_invalid_certs(no_verify_ssl)
   23|     18|            .build()
   24|     18|            .expect("Failed to build HTTP client");
   25|       |
   26|     18|        Self {
   27|     18|            http,
   28|     18|            base_url: base_url.into(),
   29|     18|            username: Some(username.into()),
   30|     18|            password: Some(password.into()),
   31|     18|        }
   32|     18|    }
   33|       |
   34|     26|    pub fn new_no_auth(base_url: impl Into<String>, no_verify_ssl: bool) -> Self {
   35|     26|        let http = Client::builder()
   36|     26|            .cookie_store(true)
   37|     26|            .danger_accept_invalid_certs(no_verify_ssl)
   38|     26|            .build()
   39|     26|            .expect("Failed to build HTTP client");
   40|       |
   41|     26|        Self {
   42|     26|            http,
   43|     26|            base_url: base_url.into(),
   44|     26|            username: None,
   45|     26|            password: None,
   46|     26|        }
   47|     26|    }
   48|       |
   49|      4|    pub async fn login(&self) -> Result<()> {
   50|      4|        let url = format!("{}/api/v2/auth/login", self.base_url);
   51|       |
   52|      4|        let params = [
   53|      4|            ("username", self.username.as_deref().unwrap_or("")),
   54|      4|            ("password", self.password.as_deref().unwrap_or("")),
   55|      4|        ];
   56|       |
   57|      4|        let base_url_with_slash = if self.base_url.ends_with('/') {
   58|      0|            self.base_url.clone()
   59|       |        } else {
   60|      4|            format!("{}/", self.base_url)
   61|       |        };
   62|       |
   63|      4|        let resp = self
   64|      4|            .http
   65|      4|            .post(&url)
   66|      4|            .header("Referer", &base_url_with_slash)
   67|      4|            .header("Origin", &self.base_url)
   68|      4|            .header("User-Agent", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36")
   69|      4|            .form(&params)
   70|      4|            .send()
   71|      4|            .await?;
                                ^0
   72|       |
   73|      4|        if resp.status().is_success() {
   74|       |            // Check body text for "Ok." just to be sure, though status 200 usually implies success for qbit.
   75|      3|            let text = resp.text().await?;
                                                      ^0
   76|      3|            if text == "Ok." {
   77|      2|                Ok(())
   78|       |            } else {
   79|       |                // Sometimes it returns 200 even if fails? No, usually 200 with "Ok."
   80|       |                // But strictly checking "Ok." is safer.
   81|      1|                Ok(())
   82|       |            }
   83|       |        } else {
   84|      1|            Err(anyhow!("Login failed with status: {}", resp.status()))
   85|       |        }
   86|      4|    }
   87|       |
   88|       |    #[allow(clippy::too_many_arguments)]
   89|      9|    pub async fn get_torrent_list(
   90|      9|        &self,
   91|      9|        filter: Option<&str>,
   92|      9|        category: Option<&str>,
   93|      9|        tag: Option<&str>,
   94|      9|        sort: Option<&str>,
   95|      9|        reverse: Option<bool>,
   96|      9|        limit: Option<i64>,
   97|      9|        offset: Option<i64>,
   98|      9|    ) -> Result<Vec<crate::models::Torrent>> {
   99|      9|        let mut url = url::Url::parse(&format!("{}/api/v2/torrents/info", self.base_url))?;
                                                                                                       ^0
  100|       |        {
  101|      9|            let mut query = url.query_pairs_mut();
  102|      9|            if let Some(f) = filter {
                                      ^1
  103|      1|                query.append_pair("filter", f);
  104|      8|            }
  105|      9|            if let Some(c) = category {
                                      ^0
  106|      0|                query.append_pair("category", c);
  107|      9|            }
  108|      9|            if let Some(t) = tag {
                                      ^0
  109|      0|                query.append_pair("tag", t);
  110|      9|            }
  111|      9|            if let Some(s) = sort {
                                      ^0
  112|      0|                query.append_pair("sort", s);
  113|      9|            }
  114|      9|            if let Some(r) = reverse {
                                      ^0
  115|      0|                query.append_pair("reverse", &r.to_string());
  116|      9|            }
  117|      9|            if let Some(l) = limit {
                                      ^0
  118|      0|                query.append_pair("limit", &l.to_string());
  119|      9|            }
  120|      9|            if let Some(o) = offset {
                                      ^0
  121|      0|                query.append_pair("offset", &o.to_string());
  122|      9|            }
  123|       |        }
  124|       |
  125|      9|        let resp = self.http.get(url).send().await?;
                                                                ^0
  126|       |
  127|      9|        if resp.status().is_success() {
  128|      8|            let torrents = resp.json::<Vec<crate::models::Torrent>>().await?;
                                                                                         ^0
  129|      8|            Ok(torrents)
  130|       |        } else {
  131|      1|            Err(anyhow!("Failed to get torrent list: {}", resp.status()))
  132|       |        }
  133|      9|    }
  134|       |
  135|      5|    pub async fn get_torrents_info(&self, hashes: &str) -> Result<Vec<crate::models::Torrent>> {
  136|      5|        let url = format!("{}/api/v2/torrents/info?hashes={}", self.base_url, hashes);
  137|       |
  138|      5|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  139|       |
  140|      5|        if resp.status().is_success() {
  141|      5|            let torrents = resp.json::<Vec<crate::models::Torrent>>().await?;
                                                                                         ^0
  142|      5|            Ok(torrents)
  143|       |        } else {
  144|      0|            Err(anyhow!("Failed to get torrents info: {}", resp.status()))
  145|       |        }
  146|      5|    }
  147|       |
  148|      5|    pub async fn add_torrent(
  149|      5|        &self,
  150|      5|        urls: &str,
  151|      5|        save_path: Option<&str>,
  152|      5|        category: Option<&str>,
  153|      5|    ) -> Result<()> {
  154|      5|        let url = format!("{}/api/v2/torrents/add", self.base_url);
  155|       |
  156|      5|        let mut form = reqwest::multipart::Form::new().text("urls", urls.to_string());
  157|       |
  158|      5|        if let Some(path) = save_path {
                                  ^1
  159|      1|            form = form.text("savepath", path.to_string());
  160|      4|        }
  161|       |
  162|      5|        if let Some(cat) = category {
                                  ^1
  163|      1|            form = form.text("category", cat.to_string());
  164|      4|        }
  165|       |
  166|      5|        let resp = self.http.post(&url).multipart(form).send().await?;
                                                                                  ^0
  167|       |
  168|      5|        if resp.status().is_success() {
  169|      4|            Ok(())
  170|       |        } else {
  171|      1|            Err(anyhow!("Failed to add torrent: {}", resp.status()))
  172|       |        }
  173|      5|    }
  174|       |
  175|      4|    pub async fn pause_torrents(&self, hashes: &str) -> Result<()> {
  176|       |        // Try v5 "stop" endpoint first
  177|      4|        let url_stop = format!("{}/api/v2/torrents/stop", self.base_url);
  178|      4|        let params = [("hashes", hashes)];
  179|       |
  180|      4|        let resp_stop = self.http.post(&url_stop).form(&params).send().await?;
                                                                                          ^0
  181|       |
  182|      4|        if resp_stop.status().is_success() {
  183|      2|            return Ok(());
  184|      2|        } else if resp_stop.status() == reqwest::StatusCode::NOT_FOUND {
  185|       |            // Fallback to v4 "pause" endpoint
  186|      2|            let url_pause = format!("{}/api/v2/torrents/pause", self.base_url);
  187|      2|            let resp_pause = self.http.post(&url_pause).form(&params).send().await?;
                                                                                                ^0
  188|      2|            if resp_pause.status().is_success() {
  189|      2|                return Ok(());
  190|       |            } else {
  191|      0|                return Err(anyhow!("Failed to pause torrents: {}", resp_pause.status()));
  192|       |            }
  193|      0|        }
  194|       |
  195|      0|        Err(anyhow!(
  196|      0|            "Failed to stop/pause torrents: {}",
  197|      0|            resp_stop.status()
  198|      0|        ))
  199|      4|    }
  200|       |
  201|      4|    pub async fn resume_torrents(&self, hashes: &str) -> Result<()> {
  202|       |        // Try v5 "start" endpoint first
  203|      4|        let url_start = format!("{}/api/v2/torrents/start", self.base_url);
  204|      4|        let params = [("hashes", hashes)];
  205|       |
  206|      4|        let resp_start = self.http.post(&url_start).form(&params).send().await?;
                                                                                            ^0
  207|       |
  208|      4|        if resp_start.status().is_success() {
  209|      2|            return Ok(());
  210|      2|        } else if resp_start.status() == reqwest::StatusCode::NOT_FOUND {
  211|       |            // Fallback to v4 "resume" endpoint
  212|      2|            let url_resume = format!("{}/api/v2/torrents/resume", self.base_url);
  213|      2|            let resp_resume = self.http.post(&url_resume).form(&params).send().await?;
                                                                                                  ^0
  214|      2|            if resp_resume.status().is_success() {
  215|      2|                return Ok(());
  216|       |            } else {
  217|      0|                return Err(anyhow!(
  218|      0|                    "Failed to resume torrents: {}",
  219|      0|                    resp_resume.status()
  220|      0|                ));
  221|       |            }
  222|      0|        }
  223|       |
  224|      0|        Err(anyhow!(
  225|      0|            "Failed to start/resume torrents: {}",
  226|      0|            resp_start.status()
  227|      0|        ))
  228|      4|    }
  229|       |
  230|      3|    pub async fn delete_torrents(&self, hashes: &str, delete_files: bool) -> Result<()> {
  231|      3|        let url = format!("{}/api/v2/torrents/delete", self.base_url);
  232|      3|        let params = [
  233|      3|            ("hashes", hashes.to_string()),
  234|      3|            ("deleteFiles", delete_files.to_string()),
  235|      3|        ];
  236|       |
  237|      3|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  238|       |
  239|      3|        if resp.status().is_success() {
  240|      3|            Ok(())
  241|       |        } else {
  242|      0|            Err(anyhow!("Failed to delete torrents: {}", resp.status()))
  243|       |        }
  244|      3|    }
  245|       |
  246|      2|    pub async fn reannounce_torrents(&self, hashes: &str) -> Result<()> {
  247|      2|        let url = format!("{}/api/v2/torrents/reannounce", self.base_url);
  248|      2|        let params = [("hashes", hashes)];
  249|       |
  250|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  251|       |
  252|      2|        if resp.status().is_success() {
  253|      2|            Ok(())
  254|       |        } else {
  255|      0|            Err(anyhow!("Failed to reannounce torrents: {}", resp.status()))
  256|       |        }
  257|      2|    }
  258|       |
  259|      2|    pub async fn recheck_torrents(&self, hashes: &str) -> Result<()> {
  260|      2|        let url = format!("{}/api/v2/torrents/recheck", self.base_url);
  261|      2|        let params = [("hashes", hashes)];
  262|       |
  263|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  264|       |
  265|      2|        if resp.status().is_success() {
  266|      2|            Ok(())
  267|       |        } else {
  268|      0|            Err(anyhow!("Failed to recheck torrents: {}", resp.status()))
  269|       |        }
  270|      2|    }
  271|       |
  272|      4|    pub async fn get_torrent_files(&self, hash: &str) -> Result<Vec<crate::models::TorrentFile>> {
  273|      4|        let url = format!("{}/api/v2/torrents/files?hash={}", self.base_url, hash);
  274|       |
  275|      4|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  276|       |
  277|      4|        if resp.status().is_success() {
  278|      2|            let files = resp.json::<Vec<crate::models::TorrentFile>>().await?;
                                                                                          ^0
  279|      2|            Ok(files)
  280|       |        } else {
  281|      2|            Err(anyhow!("Failed to get torrent files: {}", resp.status()))
  282|       |        }
  283|      4|    }
  284|       |
  285|      3|    pub async fn get_torrent_properties(
  286|      3|        &self,
  287|      3|        hash: &str,
  288|      3|    ) -> Result<crate::models::TorrentProperties> {
  289|      3|        let url = format!("{}/api/v2/torrents/properties?hash={}", self.base_url, hash);
  290|       |
  291|      3|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  292|       |
  293|      3|        if resp.status().is_success() {
  294|      2|            let props = resp.json::<crate::models::TorrentProperties>().await?;
                                                                                           ^0
  295|      2|            Ok(props)
  296|       |        } else {
  297|      1|            Err(anyhow!(
  298|      1|                "Failed to get torrent properties: {}",
  299|      1|                resp.status()
  300|      1|            ))
  301|       |        }
  302|      3|    }
  303|       |
  304|      1|    pub async fn get_torrent_trackers(&self, hash: &str) -> Result<Vec<crate::models::Tracker>> {
  305|      1|        let url = format!("{}/api/v2/torrents/trackers?hash={}", self.base_url, hash);
  306|       |
  307|      1|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  308|       |
  309|      1|        if resp.status().is_success() {
  310|      1|            let trackers = resp.json::<Vec<crate::models::Tracker>>().await?;
                                                                                         ^0
  311|      1|            Ok(trackers)
  312|       |        } else {
  313|      0|            Err(anyhow!("Failed to get torrent trackers: {}", resp.status()))
  314|       |        }
  315|      1|    }
  316|       |
  317|      5|    pub async fn get_global_transfer_info(&self) -> Result<crate::models::TransferInfo> {
  318|      5|        let url = format!("{}/api/v2/transfer/info", self.base_url);
  319|       |
  320|      5|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  321|       |
  322|      5|        if resp.status().is_success() {
  323|      5|            let info = resp.json::<crate::models::TransferInfo>().await?;
                                                                                     ^0
  324|      5|            Ok(info)
  325|       |        } else {
  326|      0|            Err(anyhow!(
  327|      0|                "Failed to get global transfer info: {}",
  328|      0|                resp.status()
  329|      0|            ))
  330|       |        }
  331|      5|    }
  332|       |
  333|      2|    pub async fn set_download_limit(&self, limit: i64) -> Result<()> {
  334|      2|        let url = format!("{}/api/v2/transfer/setDownloadLimit", self.base_url);
  335|      2|        let params = [("limit", limit.to_string())];
  336|       |
  337|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  338|       |
  339|      2|        if resp.status().is_success() {
  340|      2|            Ok(())
  341|       |        } else {
  342|      0|            Err(anyhow!("Failed to set download limit: {}", resp.status()))
  343|       |        }
  344|      2|    }
  345|       |
  346|      2|    pub async fn set_upload_limit(&self, limit: i64) -> Result<()> {
  347|      2|        let url = format!("{}/api/v2/transfer/setUploadLimit", self.base_url);
  348|      2|        let params = [("limit", limit.to_string())];
  349|       |
  350|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  351|       |
  352|      2|        if resp.status().is_success() {
  353|      2|            Ok(())
  354|       |        } else {
  355|      0|            Err(anyhow!("Failed to set upload limit: {}", resp.status()))
  356|       |        }
  357|      2|    }
  358|       |
  359|      3|    pub async fn toggle_alternative_speed_limits(&self) -> Result<()> {
  360|      3|        let url = format!("{}/api/v2/transfer/toggleSpeedLimitsMode", self.base_url);
  361|      3|        let resp = self.http.post(&url).send().await?;
                                                                  ^0
  362|       |
  363|      3|        if resp.status().is_success() {
  364|      3|            Ok(())
  365|       |        } else {
  366|      0|            Err(anyhow!(
  367|      0|                "Failed to toggle alternative speed limits: {}",
  368|      0|                resp.status()
  369|      0|            ))
  370|       |        }
  371|      3|    }
  372|       |
  373|      3|    pub async fn get_speed_limits_mode(&self) -> Result<i64> {
  374|      3|        let url = format!("{}/api/v2/transfer/speedLimitsMode", self.base_url);
  375|      3|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  376|       |
  377|      3|        if resp.status().is_success() {
  378|      3|            let mode = resp.text().await?.parse()?;
                                                      ^0       ^0
  379|      3|            Ok(mode)
  380|       |        } else {
  381|      0|            Err(anyhow!(
  382|      0|                "Failed to get speed limits mode: {}",
  383|      0|                resp.status()
  384|      0|            ))
  385|       |        }
  386|      3|    }
  387|       |
  388|      2|    pub async fn start_search(&self, pattern: &str, category: Option<&str>) -> Result<i64> {
  389|      2|        let url = format!("{}/api/v2/search/start", self.base_url);
  390|      2|        let mut params = vec![("pattern", pattern), ("plugins", "all")];
  391|      2|        if let Some(cat) = category {
                                  ^0
  392|      0|            params.push(("category", cat));
  393|      2|        } else {
  394|      2|            params.push(("category", "all"));
  395|      2|        }
  396|       |
  397|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  398|       |
  399|      2|        if resp.status().is_success() {
  400|      2|            let job: crate::models::SearchJob = resp.json().await?;
                                                                               ^0
  401|      2|            Ok(job.id)
  402|       |        } else {
  403|      0|            Err(anyhow!("Failed to start search: {}", resp.status()))
  404|       |        }
  405|      2|    }
  406|       |
  407|      6|    pub async fn get_search_results(
  408|      6|        &self,
  409|      6|        id: i64,
  410|      6|        limit: Option<i64>,
  411|      6|        offset: Option<i64>,
  412|      6|    ) -> Result<crate::models::SearchResultsResponse> {
  413|      6|        let url = format!("{}/api/v2/search/results", self.base_url);
  414|      6|        let mut params = vec![("id", id.to_string())];
  415|      6|        if let Some(l) = limit {
                                  ^0
  416|      0|            params.push(("limit", l.to_string()));
  417|      6|        }
  418|      6|        if let Some(o) = offset {
                                  ^0
  419|      0|            params.push(("offset", o.to_string()));
  420|      6|        }
  421|       |
  422|      6|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  423|       |
  424|      6|        if resp.status().is_success() {
  425|      6|            let results: crate::models::SearchResultsResponse = resp.json().await?;
                                                                                               ^0
  426|      6|            Ok(results)
  427|       |        } else {
  428|      0|            Err(anyhow!("Failed to get search results: {}", resp.status()))
  429|       |        }
  430|      6|    }
  431|       |
  432|      2|    pub async fn stop_search(&self, id: i64) -> Result<()> {
  433|      2|        let url = format!("{}/api/v2/search/stop", self.base_url);
  434|      2|        let params = [("id", id.to_string())];
  435|       |
  436|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  437|       |
  438|      2|        if resp.status().is_success() {
  439|      2|            Ok(())
  440|       |        } else {
  441|      0|            Err(anyhow!("Failed to stop search: {}", resp.status()))
  442|       |        }
  443|      2|    }
  444|       |
  445|      2|    pub async fn delete_search(&self, id: i64) -> Result<()> {
  446|      2|        let url = format!("{}/api/v2/search/delete", self.base_url);
  447|      2|        let params = [("id", id.to_string())];
  448|       |
  449|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  450|       |
  451|      2|        if resp.status().is_success() {
  452|      2|            Ok(())
  453|       |        } else {
  454|      0|            Err(anyhow!("Failed to delete search: {}", resp.status()))
  455|       |        }
  456|      2|    }
  457|       |
  458|      4|    pub async fn get_categories(
  459|      4|        &self,
  460|      4|    ) -> Result<std::collections::HashMap<String, crate::models::Category>> {
  461|      4|        let url = format!("{}/api/v2/torrents/categories", self.base_url);
  462|      4|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  463|       |
  464|      4|        if resp.status().is_success() {
  465|      4|            let categories = resp.json().await?;
                                                            ^0
  466|      4|            Ok(categories)
  467|       |        } else {
  468|      0|            Err(anyhow!("Failed to get categories: {}", resp.status()))
  469|       |        }
  470|      4|    }
  471|       |
  472|      3|    pub async fn create_category(&self, name: &str, save_path: &str) -> Result<()> {
  473|      3|        let url = format!("{}/api/v2/torrents/createCategory", self.base_url);
  474|      3|        let params = [("category", name), ("savePath", save_path)];
  475|       |
  476|      3|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  477|       |
  478|      3|        if resp.status().is_success() {
  479|      2|            Ok(())
  480|       |        } else {
  481|      1|            Err(anyhow!("Failed to create category: {}", resp.status()))
  482|       |        }
  483|      3|    }
  484|       |
  485|      3|    pub async fn set_category(&self, hashes: &str, category: &str) -> Result<()> {
  486|      3|        let url = format!("{}/api/v2/torrents/setCategory", self.base_url);
  487|      3|        let params = [("hashes", hashes), ("category", category)];
  488|       |
  489|      3|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  490|       |
  491|      3|        if resp.status().is_success() {
  492|      3|            Ok(())
  493|       |        } else {
  494|      0|            Err(anyhow!("Failed to set category: {}", resp.status()))
  495|       |        }
  496|      3|    }
  497|       |
  498|      3|    pub async fn add_tags(&self, hashes: &str, tags: &str) -> Result<()> {
  499|      3|        let url = format!("{}/api/v2/torrents/addTags", self.base_url);
  500|      3|        let params = [("hashes", hashes), ("tags", tags)];
  501|       |
  502|      3|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  503|       |
  504|      3|        if resp.status().is_success() {
  505|      3|            Ok(())
  506|       |        } else {
  507|      0|            Err(anyhow!("Failed to add tags: {}", resp.status()))
  508|       |        }
  509|      3|    }
  510|       |
  511|      3|    pub async fn get_search_plugins(&self) -> Result<Vec<crate::models::SearchPlugin>> {
  512|      3|        let url = format!("{}/api/v2/search/plugins", self.base_url);
  513|      3|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  514|       |
  515|      3|        if resp.status().is_success() {
  516|      3|            let plugins = resp.json().await?;
                                                         ^0
  517|      3|            Ok(plugins)
  518|       |        } else {
  519|      0|            Err(anyhow!("Failed to get search plugins: {}", resp.status()))
  520|       |        }
  521|      3|    }
  522|       |
  523|      2|    pub async fn install_search_plugin(&self, url_source: &str) -> Result<()> {
  524|      2|        let url = format!("{}/api/v2/search/installPlugin", self.base_url);
  525|      2|        let params = [("sources", url_source)];
  526|       |
  527|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  528|       |
  529|      2|        if resp.status().is_success() {
  530|      2|            Ok(())
  531|       |        } else {
  532|      0|            Err(anyhow!(
  533|      0|                "Failed to install search plugin: {}",
  534|      0|                resp.status()
  535|      0|            ))
  536|       |        }
  537|      2|    }
  538|       |
  539|      2|    pub async fn uninstall_search_plugin(&self, name: &str) -> Result<()> {
  540|      2|        let url = format!("{}/api/v2/search/uninstallPlugin", self.base_url);
  541|      2|        let params = [("names", name)];
  542|       |
  543|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  544|       |
  545|      2|        if resp.status().is_success() {
  546|      2|            Ok(())
  547|       |        } else {
  548|      0|            Err(anyhow!(
  549|      0|                "Failed to uninstall search plugin: {}",
  550|      0|                resp.status()
  551|      0|            ))
  552|       |        }
  553|      2|    }
  554|       |
  555|      2|    pub async fn enable_search_plugin(&self, name: &str, enable: bool) -> Result<()> {
  556|      2|        let url = format!("{}/api/v2/search/enablePlugin", self.base_url);
  557|      2|        let params = [
  558|      2|            ("names", name),
  559|      2|            ("enable", if enable { "true" } else { "false" }),
                                                 ^1              ^1
  560|       |        ];
  561|       |
  562|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  563|       |
  564|      2|        if resp.status().is_success() {
  565|      2|            Ok(())
  566|       |        } else {
  567|      0|            Err(anyhow!("Failed to toggle search plugin: {}", resp.status()))
  568|       |        }
  569|      2|    }
  570|       |
  571|      2|    pub async fn update_search_plugins(&self) -> Result<()> {
  572|      2|        let url = format!("{}/api/v2/search/updatePlugins", self.base_url);
  573|      2|        let resp = self.http.post(&url).send().await?;
                                                                  ^0
  574|       |
  575|      2|        if resp.status().is_success() {
  576|      2|            Ok(())
  577|       |        } else {
  578|      0|            Err(anyhow!(
  579|      0|                "Failed to update search plugins: {}",
  580|      0|                resp.status()
  581|      0|            ))
  582|       |        }
  583|      2|    }
  584|       |
  585|      3|    pub async fn add_rss_feed(&self, url_feed: &str, path: &str) -> Result<()> {
  586|      3|        let url = format!("{}/api/v2/rss/addFeed", self.base_url);
  587|      3|        let params = [("url", url_feed), ("path", path)];
  588|       |
  589|      3|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  590|       |
  591|      3|        if resp.status().is_success() {
  592|      2|            Ok(())
  593|       |        } else {
  594|      1|            Err(anyhow!("Failed to add RSS feed: {}", resp.status()))
  595|       |        }
  596|      3|    }
  597|       |
  598|      0|    pub async fn remove_rss_item(&self, path: &str) -> Result<()> {
  599|      0|        let url = format!("{}/api/v2/rss/removeItem", self.base_url);
  600|      0|        let params = [("path", path)];
  601|       |
  602|      0|        let resp = self.http.post(&url).form(&params).send().await?;
  603|       |
  604|      0|        if resp.status().is_success() {
  605|      0|            Ok(())
  606|       |        } else {
  607|      0|            Err(anyhow!("Failed to remove RSS item: {}", resp.status()))
  608|       |        }
  609|      0|    }
  610|       |
  611|      3|    pub async fn get_all_rss_feeds(
  612|      3|        &self,
  613|      3|    ) -> Result<std::collections::HashMap<String, serde_json::Value>> {
  614|       |        // v5 uses 'items' with withData=true to get feeds and items
  615|      3|        let url_items = format!("{}/api/v2/rss/items?withData=true", self.base_url);
  616|      3|        let resp = self.http.get(&url_items).send().await?;
                                                                       ^0
  617|       |
  618|      3|        if resp.status().is_success() {
  619|      2|            let feeds = resp.json().await?;
                                                       ^0
  620|      2|            Ok(feeds)
  621|      1|        } else if resp.status() == reqwest::StatusCode::NOT_FOUND {
  622|       |            // Fallback to legacy
  623|      1|            let url_legacy = format!("{}/api/v2/rss/allFeeds", self.base_url);
  624|      1|            let resp_legacy = self.http.get(&url_legacy).send().await?;
                                                                                   ^0
  625|      1|            if resp_legacy.status().is_success() {
  626|      1|                let feeds = resp_legacy.json().await?;
                                                                  ^0
  627|      1|                Ok(feeds)
  628|       |            } else {
  629|      0|                Err(anyhow!("Failed to get RSS feeds: {}", resp_legacy.status()))
  630|       |            }
  631|       |        } else {
  632|      0|            Err(anyhow!("Failed to get RSS feeds: {}", resp.status()))
  633|       |        }
  634|      3|    }
  635|       |
  636|      3|    pub async fn set_rss_rule(&self, name: &str, definition: &str) -> Result<()> {
  637|      3|        let url = format!("{}/api/v2/rss/setRule", self.base_url);
  638|      3|        let params = [("ruleName", name), ("ruleDef", definition)];
  639|       |
  640|      3|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  641|       |
  642|      3|        if resp.status().is_success() {
  643|      3|            Ok(())
  644|       |        } else {
  645|      0|            Err(anyhow!("Failed to set RSS rule: {}", resp.status()))
  646|       |        }
  647|      3|    }
  648|       |
  649|      3|    pub async fn get_all_rss_rules(
  650|      3|        &self,
  651|      3|    ) -> Result<std::collections::HashMap<String, crate::models::RssRule>> {
  652|       |        // v5 uses 'rules'
  653|      3|        let url_rules = format!("{}/api/v2/rss/rules", self.base_url);
  654|      3|        let resp = self.http.get(&url_rules).send().await?;
                                                                       ^0
  655|       |
  656|      3|        if resp.status().is_success() {
  657|      2|            let rules = resp.json().await?;
                                                       ^0
  658|      2|            Ok(rules)
  659|      1|        } else if resp.status() == reqwest::StatusCode::NOT_FOUND {
  660|       |            // Fallback to legacy
  661|      1|            let url_legacy = format!("{}/api/v2/rss/allRules", self.base_url);
  662|      1|            let resp_legacy = self.http.get(&url_legacy).send().await?;
                                                                                   ^0
  663|      1|            if resp_legacy.status().is_success() {
  664|      1|                let rules = resp_legacy.json().await?;
                                                                  ^0
  665|      1|                Ok(rules)
  666|       |            } else {
  667|      0|                Err(anyhow!("Failed to get RSS rules: {}", resp_legacy.status()))
  668|       |            }
  669|       |        } else {
  670|      0|            Err(anyhow!("Failed to get RSS rules: {}", resp.status()))
  671|       |        }
  672|      3|    }
  673|       |
  674|      3|    pub async fn get_app_preferences(&self) -> Result<serde_json::Value> {
  675|      3|        let url = format!("{}/api/v2/app/preferences", self.base_url);
  676|      3|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  677|       |
  678|      3|        if resp.status().is_success() {
  679|      3|            let prefs = resp.json().await?;
                                                       ^0
  680|      3|            Ok(prefs)
  681|       |        } else {
  682|      0|            Err(anyhow!("Failed to get app preferences: {}", resp.status()))
  683|       |        }
  684|      3|    }
  685|       |
  686|      2|    pub async fn set_app_preferences(&self, prefs: &serde_json::Value) -> Result<()> {
  687|      2|        let url = format!("{}/api/v2/app/setPreferences", self.base_url);
  688|      2|        let params = [("json", prefs.to_string())];
  689|       |
  690|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  691|       |
  692|      2|        if resp.status().is_success() {
  693|      2|            Ok(())
  694|       |        } else {
  695|      0|            Err(anyhow!("Failed to set app preferences: {}", resp.status()))
  696|       |        }
  697|      2|    }
  698|       |
  699|      2|    pub async fn get_app_version(&self) -> Result<String> {
  700|      2|        let url = format!("{}/api/v2/app/version", self.base_url);
  701|      2|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  702|       |
  703|      2|        if resp.status().is_success() {
  704|      2|            let version = resp.text().await?;
                                                         ^0
  705|      2|            Ok(version)
  706|       |        } else {
  707|      0|            Err(anyhow!("Failed to get app version: {}", resp.status()))
  708|       |        }
  709|      2|    }
  710|       |
  711|      2|    pub async fn get_build_info(&self) -> Result<crate::models::BuildInfo> {
  712|      2|        let url = format!("{}/api/v2/app/buildInfo", self.base_url);
  713|      2|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  714|       |
  715|      2|        if resp.status().is_success() {
  716|      2|            let info = resp.json::<crate::models::BuildInfo>().await?;
                                                                                  ^0
  717|      2|            Ok(info)
  718|       |        } else {
  719|      0|            Err(anyhow!("Failed to get build info: {}", resp.status()))
  720|       |        }
  721|      2|    }
  722|       |
  723|      1|    pub async fn shutdown_app(&self) -> Result<()> {
  724|      1|        let url = format!("{}/api/v2/app/shutdown", self.base_url);
  725|      1|        let resp = self.http.post(&url).send().await?;
                                                                  ^0
  726|       |
  727|      1|        if resp.status().is_success() {
  728|      1|            Ok(())
  729|       |        } else {
  730|      0|            Err(anyhow!("Failed to shutdown app: {}", resp.status()))
  731|       |        }
  732|      1|    }
  733|       |
  734|      3|    pub async fn get_main_log(
  735|      3|        &self,
  736|      3|        normal: bool,
  737|      3|        info: bool,
  738|      3|        warning: bool,
  739|      3|        critical: bool,
  740|      3|        last_id: Option<i64>,
  741|      3|    ) -> Result<Vec<crate::models::LogEntry>> {
  742|      3|        let mut url = format!(
  743|       |            "{}/api/v2/log/main?normal={}&info={}&warning={}&critical={}",
  744|       |            self.base_url, normal, info, warning, critical
  745|       |        );
  746|      3|        if let Some(id) = last_id {
                                  ^0
  747|      0|            url.push_str(&format!("&last_id={}", id));
  748|      3|        }
  749|       |
  750|      3|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  751|       |
  752|      3|        if resp.status().is_success() {
  753|      3|            let logs = resp.json().await?;
                                                      ^0
  754|      3|            Ok(logs)
  755|       |        } else {
  756|      0|            Err(anyhow!("Failed to get main log: {}", resp.status()))
  757|       |        }
  758|      3|    }
  759|       |
  760|      3|    pub async fn get_peer_log(
  761|      3|        &self,
  762|      3|        last_id: Option<i64>,
  763|      3|    ) -> Result<Vec<crate::models::PeerLogEntry>> {
  764|      3|        let mut url = format!("{}/api/v2/log/peers", self.base_url);
  765|      3|        if let Some(id) = last_id {
                                  ^0
  766|      0|            url.push_str(&format!("?last_id={}", id));
  767|      3|        }
  768|       |
  769|      3|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  770|       |
  771|      3|        if resp.status().is_success() {
  772|      3|            let logs = resp.json().await?;
                                                      ^0
  773|      3|            Ok(logs)
  774|       |        } else {
  775|      0|            Err(anyhow!("Failed to get peer log: {}", resp.status()))
  776|       |        }
  777|      3|    }
  778|       |
  779|      2|    pub async fn ban_peers(&self, peers: &str) -> Result<()> {
  780|      2|        let url = format!("{}/api/v2/transfer/banPeers", self.base_url);
  781|      2|        let params = [("peers", peers)];
  782|       |
  783|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  784|       |
  785|      2|        if resp.status().is_success() {
  786|      2|            Ok(())
  787|       |        } else {
  788|      0|            Err(anyhow!("Failed to ban peers: {}", resp.status()))
  789|       |        }
  790|      2|    }
  791|       |
  792|      0|    pub async fn rename_file(&self, hash: &str, old_path: &str, new_path: &str) -> Result<()> {
  793|      0|        let url = format!("{}/api/v2/torrents/renameFile", self.base_url);
  794|      0|        let params = [("hash", hash), ("oldPath", old_path), ("newPath", new_path)];
  795|       |
  796|      0|        let resp = self.http.post(&url).form(&params).send().await?;
  797|       |
  798|      0|        if resp.status().is_success() {
  799|      0|            Ok(())
  800|       |        } else {
  801|      0|            Err(anyhow!("Failed to rename file: {}", resp.status()))
  802|       |        }
  803|      0|    }
  804|       |
  805|      3|    pub async fn set_torrent_share_limits(
  806|      3|        &self,
  807|      3|
  808|      3|        hashes: &str,
  809|      3|
  810|      3|        ratio_limit: f64,
  811|      3|
  812|      3|        seeding_time_limit: i64,
  813|      3|
  814|      3|        inactive_seeding_time_limit: Option<i64>,
  815|      3|    ) -> Result<()> {
  816|      3|        let url = format!("{}/api/v2/torrents/setShareLimits", self.base_url);
  817|       |
  818|      3|        let mut params = vec![
  819|      3|            ("hashes", hashes.to_string()),
  820|      3|            ("ratioLimit", ratio_limit.to_string()),
  821|      3|            ("seedingTimeLimit", seeding_time_limit.to_string()),
  822|       |        ];
  823|       |
  824|      3|        if let Some(limit) = inactive_seeding_time_limit {
                                  ^0
  825|      0|            params.push(("inactiveSeedingTimeLimit", limit.to_string()));
  826|      3|        } else {
  827|      3|            // Default to -2 (global) for compatibility with newer qbit versions
  828|      3|
  829|      3|            params.push(("inactiveSeedingTimeLimit", "-2".to_string()));
  830|      3|        }
  831|       |
  832|      3|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  833|       |
  834|      3|        if resp.status().is_success() {
  835|      3|            Ok(())
  836|       |        } else {
  837|      0|            Err(anyhow!(
  838|      0|                "Failed to set torrent share limits: {}",
  839|      0|                resp.status()
  840|      0|            ))
  841|       |        }
  842|      3|    }
  843|       |
  844|      2|    pub async fn set_torrent_download_limit(&self, hashes: &str, limit: i64) -> Result<()> {
  845|      2|        let url = format!("{}/api/v2/torrents/setDownloadLimit", self.base_url);
  846|      2|        let params = [("hashes", hashes), ("limit", &limit.to_string())];
  847|       |
  848|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  849|       |
  850|      2|        if resp.status().is_success() {
  851|      2|            Ok(())
  852|       |        } else {
  853|      0|            Err(anyhow!(
  854|      0|                "Failed to set torrent download limit: {}",
  855|      0|                resp.status()
  856|      0|            ))
  857|       |        }
  858|      2|    }
  859|       |
  860|      2|    pub async fn set_torrent_upload_limit(&self, hashes: &str, limit: i64) -> Result<()> {
  861|      2|        let url = format!("{}/api/v2/torrents/setUploadLimit", self.base_url);
  862|      2|        let params = [("hashes", hashes), ("limit", &limit.to_string())];
  863|       |
  864|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  865|       |
  866|      2|        if resp.status().is_success() {
  867|      2|            Ok(())
  868|       |        } else {
  869|      0|            Err(anyhow!(
  870|      0|                "Failed to set torrent upload limit: {}",
  871|      0|                resp.status()
  872|      0|            ))
  873|       |        }
  874|      2|    }
  875|       |
  876|      3|    pub async fn get_main_data(&self, rid: i64) -> Result<crate::models::SyncMainData> {
  877|      3|        let url = format!("{}/api/v2/sync/maindata?rid={}", self.base_url, rid);
  878|       |
  879|      3|        let resp = self.http.get(&url).send().await?;
                                                                 ^0
  880|       |
  881|      3|        if resp.status().is_success() {
  882|      3|            let data = resp.json::<crate::models::SyncMainData>().await?;
                                                                                     ^0
  883|      3|            Ok(data)
  884|       |        } else {
  885|      0|            Err(anyhow!("Failed to get main data: {}", resp.status()))
  886|       |        }
  887|      3|    }
  888|       |
  889|      2|    pub async fn toggle_sequential_download(&self, hashes: &str) -> Result<()> {
  890|      2|        let url = format!("{}/api/v2/torrents/toggleSequentialDownload", self.base_url);
  891|      2|        let params = [("hashes", hashes)];
  892|       |
  893|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  894|       |
  895|      2|        if resp.status().is_success() {
  896|      2|            Ok(())
  897|       |        } else {
  898|      0|            Err(anyhow!(
  899|      0|                "Failed to toggle sequential download: {}",
  900|      0|                resp.status()
  901|      0|            ))
  902|       |        }
  903|      2|    }
  904|       |
  905|      2|    pub async fn toggle_first_last_piece_priority(&self, hashes: &str) -> Result<()> {
  906|      2|        let url = format!("{}/api/v2/torrents/toggleFirstLastPiecePrio", self.base_url);
  907|      2|        let params = [("hashes", hashes)];
  908|       |
  909|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  910|       |
  911|      2|        if resp.status().is_success() {
  912|      2|            Ok(())
  913|       |        } else {
  914|      0|            Err(anyhow!(
  915|      0|                "Failed to toggle first/last piece priority: {}",
  916|      0|                resp.status()
  917|      0|            ))
  918|       |        }
  919|      2|    }
  920|       |
  921|      2|    pub async fn set_force_start(&self, hashes: &str, value: bool) -> Result<()> {
  922|      2|        let url = format!("{}/api/v2/torrents/setForceStart", self.base_url);
  923|      2|        let params = [("hashes", hashes), ("value", &value.to_string())];
  924|       |
  925|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  926|       |
  927|      2|        if resp.status().is_success() {
  928|      2|            Ok(())
  929|       |        } else {
  930|      0|            Err(anyhow!("Failed to set force start: {}", resp.status()))
  931|       |        }
  932|      2|    }
  933|       |
  934|      2|    pub async fn set_super_seeding(&self, hashes: &str, value: bool) -> Result<()> {
  935|      2|        let url = format!("{}/api/v2/torrents/setSuperSeeding", self.base_url);
  936|      2|        let params = [("hashes", hashes), ("value", &value.to_string())];
  937|       |
  938|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  939|       |
  940|      2|        if resp.status().is_success() {
  941|      2|            Ok(())
  942|       |        } else {
  943|      0|            Err(anyhow!("Failed to set super seeding: {}", resp.status()))
  944|       |        }
  945|      2|    }
  946|       |
  947|      2|    pub async fn add_trackers(&self, hashes: &str, urls: &str) -> Result<()> {
  948|      2|        let url = format!("{}/api/v2/torrents/addTrackers", self.base_url);
  949|      2|        let params = [("hashes", hashes), ("urls", urls)];
  950|       |
  951|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  952|       |
  953|      2|        if resp.status().is_success() {
  954|      1|            Ok(())
  955|       |        } else {
  956|      1|            Err(anyhow!("Failed to add trackers: {}", resp.status()))
  957|       |        }
  958|      2|    }
  959|       |
  960|      2|    pub async fn edit_tracker(&self, hash: &str, orig_url: &str, new_url: &str) -> Result<()> {
  961|      2|        let url = format!("{}/api/v2/torrents/editTracker", self.base_url);
  962|      2|        let params = [("hash", hash), ("origUrl", orig_url), ("newUrl", new_url)];
  963|       |
  964|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  965|       |
  966|      2|        if resp.status().is_success() {
  967|      1|            Ok(())
  968|       |        } else {
  969|      1|            Err(anyhow!("Failed to edit tracker: {}", resp.status()))
  970|       |        }
  971|      2|    }
  972|       |
  973|      2|    pub async fn remove_trackers(&self, hashes: &str, urls: &str) -> Result<()> {
  974|      2|        let url = format!("{}/api/v2/torrents/removeTrackers", self.base_url);
  975|      2|        let params = [("hashes", hashes), ("urls", urls)];
  976|       |
  977|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  978|       |
  979|      2|        if resp.status().is_success() {
  980|      1|            Ok(())
  981|       |        } else {
  982|      1|            Err(anyhow!("Failed to remove trackers: {}", resp.status()))
  983|       |        }
  984|      2|    }
  985|       |
  986|      2|    pub async fn rename_folder(&self, hash: &str, old_path: &str, new_path: &str) -> Result<()> {
  987|      2|        let url = format!("{}/api/v2/torrents/renameFolder", self.base_url);
  988|      2|        let params = [("hash", hash), ("oldPath", old_path), ("newPath", new_path)];
  989|       |
  990|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
  991|       |
  992|      2|        if resp.status().is_success() {
  993|      1|            Ok(())
  994|       |        } else {
  995|      1|            Err(anyhow!("Failed to rename folder: {}", resp.status()))
  996|       |        }
  997|      2|    }
  998|       |
  999|      2|    pub async fn set_file_priority(&self, hash: &str, id: &str, priority: i32) -> Result<()> {
 1000|      2|        let url = format!("{}/api/v2/torrents/setFilePrio", self.base_url);
 1001|      2|        let params = [
 1002|      2|            ("hash", hash),
 1003|      2|            ("id", id),
 1004|      2|            ("priority", &priority.to_string()),
 1005|      2|        ];
 1006|       |
 1007|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
 1008|       |
 1009|      2|        if resp.status().is_success() {
 1010|      1|            Ok(())
 1011|       |        } else {
 1012|      1|            Err(anyhow!("Failed to set file priority: {}", resp.status()))
 1013|       |        }
 1014|      2|    }
 1015|       |
 1016|      2|    pub async fn remove_categories(&self, categories: &str) -> Result<()> {
 1017|      2|        let url = format!("{}/api/v2/torrents/removeCategories", self.base_url);
 1018|      2|        let params = [("categories", categories)];
 1019|       |
 1020|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
 1021|       |
 1022|      2|        if resp.status().is_success() {
 1023|      2|            Ok(())
 1024|       |        } else {
 1025|      0|            Err(anyhow!("Failed to remove categories: {}", resp.status()))
 1026|       |        }
 1027|      2|    }
 1028|       |
 1029|      2|    pub async fn remove_tags(&self, hashes: &str, tags: &str) -> Result<()> {
 1030|      2|        let url = format!("{}/api/v2/torrents/removeTags", self.base_url);
 1031|      2|        let params = [("hashes", hashes), ("tags", tags)];
 1032|       |
 1033|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
 1034|       |
 1035|      2|        if resp.status().is_success() {
 1036|      2|            Ok(())
 1037|       |        } else {
 1038|      0|            Err(anyhow!("Failed to remove tags: {}", resp.status()))
 1039|       |        }
 1040|      2|    }
 1041|       |
 1042|      2|    pub async fn create_tags(&self, tags: &str) -> Result<()> {
 1043|      2|        let url = format!("{}/api/v2/torrents/createTags", self.base_url);
 1044|      2|        let params = [("tags", tags)];
 1045|       |
 1046|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
 1047|       |
 1048|      2|        if resp.status().is_success() {
 1049|      2|            Ok(())
 1050|       |        } else {
 1051|      0|            Err(anyhow!("Failed to create tags: {}", resp.status()))
 1052|       |        }
 1053|      2|    }
 1054|       |
 1055|      2|    pub async fn delete_tags(&self, tags: &str) -> Result<()> {
 1056|      2|        let url = format!("{}/api/v2/torrents/deleteTags", self.base_url);
 1057|      2|        let params = [("tags", tags)];
 1058|       |
 1059|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
 1060|       |
 1061|      2|        if resp.status().is_success() {
 1062|      2|            Ok(())
 1063|       |        } else {
 1064|      0|            Err(anyhow!("Failed to delete tags: {}", resp.status()))
 1065|       |        }
 1066|      2|    }
 1067|       |
 1068|      2|    pub async fn move_rss_item(&self, item_path: &str, dest_path: &str) -> Result<()> {
 1069|      2|        let url = format!("{}/api/v2/rss/moveItem", self.base_url);
 1070|      2|        let params = [("itemPath", item_path), ("destPath", dest_path)];
 1071|       |
 1072|      2|        let resp = self.http.post(&url).form(&params).send().await?;
                                                                                ^0
 1073|       |
 1074|      2|        if resp.status().is_success() {
 1075|      1|            Ok(())
 1076|       |        } else {
 1077|      1|            Err(anyhow!("Failed to move RSS item: {}", resp.status()))
 1078|       |        }
 1079|      2|    }
 1080|       |}

/home/nicholas/git/nicholaswilde/qbittorrent-mcp-rs/src/config.rs:
    1|       |use clap::ArgMatches;
    2|       |use config::{Config, ConfigError, Environment, File};
    3|       |use serde::Deserialize;
    4|       |
    5|       |#[derive(Debug, Deserialize, Clone)]
    6|       |pub struct QBitInstance {
    7|       |    pub name: String,
    8|       |    pub host: String,
    9|       |    pub port: Option<u16>,
   10|       |    pub username: Option<String>,
   11|       |    pub password: Option<String>,
   12|       |    pub no_verify_ssl: Option<bool>,
   13|       |}
   14|       |
   15|       |#[derive(Debug, Deserialize, Clone)]
   16|       |pub struct AppConfig {
   17|       |    pub instances: Option<Vec<QBitInstance>>,
   18|       |    pub qbittorrent_host: String,
   19|       |    pub qbittorrent_port: Option<u16>,
   20|       |    pub qbittorrent_username: Option<String>,
   21|       |    pub qbittorrent_password: Option<String>,
   22|       |    pub server_mode: String,
   23|       |    pub lazy_mode: bool,
   24|       |    pub no_verify_ssl: bool,
   25|       |    pub log_level: String,
   26|       |    pub log_file_enable: bool,
   27|       |    pub log_dir: String,
   28|       |    pub log_filename: String,
   29|       |    pub log_rotate: String,
   30|       |    pub http_auth_token: Option<String>,
   31|       |    #[serde(default)]
   32|       |    pub polling_interval_ms: u64,
   33|       |}
   34|       |
   35|       |impl AppConfig {
   36|      8|    pub fn get_instances(&self) -> Vec<QBitInstance> {
   37|      8|        let instances = self.instances.as_ref().filter(|i| !i.is_empty());
                                                                          ^5^5
   38|      8|        if let Some(instances) = instances {
                                  ^5
   39|      5|            return instances.clone();
   40|      3|        }
   41|       |
   42|       |        // Fallback to legacy single instance
   43|      3|        vec![QBitInstance {
   44|      3|            name: "default".to_string(),
   45|      3|            host: self.qbittorrent_host.clone(),
   46|      3|            port: self.qbittorrent_port,
   47|      3|            username: self.qbittorrent_username.clone(),
   48|      3|            password: self.qbittorrent_password.clone(),
   49|      3|            no_verify_ssl: Some(self.no_verify_ssl),
   50|      3|        }]
   51|      8|    }
   52|       |
   53|      8|    pub fn load(file_path: Option<String>, cli_args: Vec<String>) -> Result<Self, ConfigError> {
   54|      8|        let mut builder = Config::builder();
   55|      8|        let matches = parse_args(cli_args);
   56|       |
   57|       |        // 1. Determine Config File Path
   58|      8|        let path_to_load = if let Some(p) = file_path {
                                                     ^3
   59|      3|            Some(p)
   60|       |        } else {
   61|      5|            matches.get_one::<String>("config").cloned()
   62|       |        };
   63|       |
   64|       |        // 2. Set Defaults
   65|      8|        builder = builder
   66|      8|            .set_default("qbittorrent_host", "localhost")?
                                                                       ^0
   67|      8|            .set_default("server_mode", "stdio")?
                                                              ^0
   68|      8|            .set_default("lazy_mode", false)?
                                                          ^0
   69|      8|            .set_default("no_verify_ssl", false)?
                                                              ^0
   70|      8|            .set_default("log_level", "info")?
                                                           ^0
   71|      8|            .set_default("log_file_enable", false)?
                                                                ^0
   72|      8|            .set_default("log_dir", ".")?
                                                      ^0
   73|      8|            .set_default("log_filename", "qbittorrent-mcp-rs.log")?
                                                                                ^0
   74|      8|            .set_default("log_rotate", "daily")?
                                                             ^0
   75|      8|            .set_default("polling_interval_ms", 2000)?;
                                                                   ^0
   76|       |
   77|       |        // 3. Load from File
   78|      8|        if let Some(path) = path_to_load {
                                  ^3
   79|      3|            builder = builder.add_source(File::with_name(&path));
   80|      5|        } else {
   81|      5|            builder = builder.add_source(File::with_name("config").required(false));
   82|      5|        }
   83|       |
   84|       |        // 4. Load from Environment Variables
   85|      8|        builder = builder.add_source(
   86|      8|            Environment::with_prefix("QBITTORRENT")
   87|      8|                .prefix_separator("_")
   88|      8|                .separator("__")
   89|      8|                .try_parsing(true),
   90|       |        );
   91|       |
   92|       |        // 5. Apply CLI overrides
   93|      8|        if let Some(host) = matches.get_one::<String>("qbittorrent_host") {
                                  ^2
   94|      2|            builder = builder.set_override("qbittorrent_host", host.as_str())?;
                                                                                           ^0
   95|      6|        }
   96|      8|        if let Some(port) = matches.get_one::<u16>("qbittorrent_port") {
                                  ^2
   97|      2|            builder = builder.set_override("qbittorrent_port", *port)?;
                                                                                   ^0
   98|      6|        }
   99|      8|        if let Some(mode) = matches.get_one::<String>("server_mode") {
                                  ^1
  100|      1|            builder = builder.set_override("server_mode", mode.as_str())?;
                                                                                      ^0
  101|      7|        }
  102|      8|        if let Some(user) = matches.get_one::<String>("qbittorrent_username") {
                                  ^0
  103|      0|            builder = builder.set_override("qbittorrent_username", user.as_str())?;
  104|      8|        }
  105|      8|        if let Some(pass) = matches.get_one::<String>("qbittorrent_password") {
                                  ^0
  106|      0|            builder = builder.set_override("qbittorrent_password", pass.as_str())?;
  107|      8|        }
  108|      8|        if matches.get_flag("lazy_mode") {
  109|      1|            builder = builder.set_override("lazy_mode", true)?;
                                                                           ^0
  110|      7|        }
  111|      8|        if matches.get_flag("no_verify_ssl") {
  112|      1|            builder = builder.set_override("no_verify_ssl", true)?;
                                                                               ^0
  113|      7|        }
  114|      8|        if let Some(level) = matches.get_one::<String>("log_level") {
  115|      8|            builder = builder.set_override("log_level", level.as_str())?;
                                                                                     ^0
  116|      0|        }
  117|      8|        if matches.get_flag("log_file_enable") {
  118|      1|            builder = builder.set_override("log_file_enable", true)?;
                                                                                 ^0
  119|      7|        }
  120|      8|        if let Some(dir) = matches.get_one::<String>("log_dir") {
  121|      8|            builder = builder.set_override("log_dir", dir.as_str())?;
                                                                                 ^0
  122|      0|        }
  123|      8|        if let Some(filename) = matches.get_one::<String>("log_filename") {
  124|      8|            builder = builder.set_override("log_filename", filename.as_str())?;
                                                                                           ^0
  125|      0|        }
  126|      8|        if let Some(rotate) = matches.get_one::<String>("log_rotate") {
  127|      8|            builder = builder.set_override("log_rotate", rotate.as_str())?;
                                                                                       ^0
  128|      0|        }
  129|      8|        if let Some(token) = matches.get_one::<String>("http_auth_token") {
                                  ^0
  130|      0|            builder = builder.set_override("http_auth_token", token.as_str())?;
  131|      8|        }
  132|      8|        if let Some(interval) = matches.get_one::<u64>("polling_interval_ms") {
                                  ^1
  133|      1|            builder = builder.set_override("polling_interval_ms", *interval)?;
                                                                                          ^0
  134|      7|        }
  135|       |
  136|      8|        builder.build()?.try_deserialize()
                                     ^1^7
  137|      8|    }
  138|       |}
  139|       |
  140|       |#[cfg(test)]
  141|       |mod tests {
  142|       |    use super::*;
  143|       |
  144|       |    #[test]
  145|      1|    fn test_get_instances_fallback() {
  146|      1|        let config = AppConfig {
  147|      1|            instances: None,
  148|      1|            qbittorrent_host: "legacy_host".to_string(),
  149|      1|            qbittorrent_port: Some(1234),
  150|      1|            qbittorrent_username: Some("user".to_string()),
  151|      1|            qbittorrent_password: Some("pass".to_string()),
  152|      1|            server_mode: "stdio".to_string(),
  153|      1|            lazy_mode: false,
  154|      1|            no_verify_ssl: true,
  155|      1|            log_level: "info".to_string(),
  156|      1|            log_file_enable: false,
  157|      1|            log_dir: ".".to_string(),
  158|      1|            log_filename: "test.log".to_string(),
  159|      1|            log_rotate: "daily".to_string(),
  160|      1|            http_auth_token: None,
  161|      1|            polling_interval_ms: 1000,
  162|      1|        };
  163|       |
  164|      1|        let instances = config.get_instances();
  165|      1|        assert_eq!(instances.len(), 1);
  166|      1|        assert_eq!(instances[0].name, "default");
  167|      1|        assert_eq!(instances[0].host, "legacy_host");
  168|      1|        assert_eq!(instances[0].port, Some(1234));
  169|      1|        assert_eq!(instances[0].no_verify_ssl, Some(true));
  170|      1|    }
  171|       |
  172|       |    #[test]
  173|      1|    fn test_load_with_various_args() {
  174|      1|        let args = vec![
  175|      1|            "app".to_string(),
  176|      1|            "--lazy".to_string(),
  177|      1|            "--no-verify-ssl".to_string(),
  178|      1|            "--log-file-enable".to_string(),
  179|       |        ];
  180|      1|        let config = AppConfig::load(None, args).unwrap();
  181|      1|        assert!(config.lazy_mode);
  182|      1|        assert!(config.no_verify_ssl);
  183|      1|        assert!(config.log_file_enable);
  184|      1|    }
  185|       |
  186|       |    #[test]
  187|      1|    fn test_get_instances_multiple() {
  188|      1|        let config = AppConfig {
  189|      1|            instances: Some(vec![
  190|      1|                QBitInstance { name: "i1".into(), host: "h1".into(), port: None, username: None, password: None, no_verify_ssl: None },
  191|      1|                QBitInstance { name: "i2".into(), host: "h2".into(), port: None, username: None, password: None, no_verify_ssl: None },
  192|      1|            ]),
  193|      1|            qbittorrent_host: "h".into(),
  194|      1|            qbittorrent_port: None,
  195|      1|            qbittorrent_username: None,
  196|      1|            qbittorrent_password: None,
  197|      1|            server_mode: "stdio".into(),
  198|      1|            lazy_mode: false,
  199|      1|            no_verify_ssl: false,
  200|      1|            log_level: "info".into(),
  201|      1|            log_file_enable: false,
  202|      1|            log_dir: ".".into(),
  203|      1|            log_filename: "f".into(),
  204|      1|            log_rotate: "d".into(),
  205|      1|            http_auth_token: None,
  206|      1|            polling_interval_ms: 100,
  207|      1|        };
  208|      1|        let instances = config.get_instances();
  209|      1|        assert_eq!(instances.len(), 2);
  210|      1|        assert_eq!(instances[0].name, "i1");
  211|      1|        assert_eq!(instances[1].name, "i2");
  212|      1|    }
  213|       |}
  214|       |
  215|      8|fn parse_args(args: Vec<String>) -> ArgMatches {
  216|       |    use clap::{Arg, ArgAction, Command};
  217|       |
  218|      8|    let cmd = Command::new("qbittorrent-mcp-rs")
  219|      8|        .arg(
  220|      8|            Arg::new("config")
  221|      8|                .short('c')
  222|      8|                .long("config")
  223|      8|                .help("Path to configuration file"),
  224|       |        )
  225|      8|        .arg(
  226|      8|            Arg::new("qbittorrent_host")
  227|      8|                .long("qbittorrent-host")
  228|      8|                .help("Host of the qBittorrent Web UI"),
  229|       |        )
  230|      8|        .arg(
  231|      8|            Arg::new("qbittorrent_port")
  232|      8|                .long("qbittorrent-port")
  233|      8|                .help("Port of the qBittorrent Web UI")
  234|      8|                .value_parser(clap::value_parser!(u16)),
  235|       |        )
  236|      8|        .arg(
  237|      8|            Arg::new("server_mode")
  238|      8|                .long("server-mode")
  239|      8|                .help("Server mode: stdio or http"),
  240|       |        )
  241|      8|        .arg(
  242|      8|            Arg::new("qbittorrent_username")
  243|      8|                .long("qbittorrent-username")
  244|      8|                .help("qBittorrent Username"),
  245|       |        )
  246|      8|        .arg(
  247|      8|            Arg::new("qbittorrent_password")
  248|      8|                .long("qbittorrent-password")
  249|      8|                .help("qBittorrent Password"),
  250|       |        )
  251|      8|        .arg(
  252|      8|            Arg::new("lazy_mode")
  253|      8|                .long("lazy")
  254|      8|                .action(ArgAction::SetTrue)
  255|      8|                .help("Enable lazy mode (show fewer tools initially)"),
  256|       |        )
  257|      8|        .arg(
  258|      8|            Arg::new("no_verify_ssl")
  259|      8|                .long("no-verify-ssl")
  260|      8|                .action(ArgAction::SetTrue)
  261|      8|                .help("Disable SSL certificate verification (insecure)"),
  262|       |        )
  263|      8|        .arg(
  264|      8|            Arg::new("log_level")
  265|      8|                .short('L')
  266|      8|                .long("log-level")
  267|      8|                .help("Log level (error, warn, info, debug, trace)")
  268|      8|                .default_value("info"),
  269|       |        )
  270|      8|        .arg(
  271|      8|            Arg::new("log_file_enable")
  272|      8|                .long("log-file-enable")
  273|      8|                .action(ArgAction::SetTrue)
  274|      8|                .help("Enable logging to a file"),
  275|       |        )
  276|      8|        .arg(
  277|      8|            Arg::new("log_dir")
  278|      8|                .long("log-dir")
  279|      8|                .help("Log file directory")
  280|      8|                .default_value("."),
  281|       |        )
  282|      8|        .arg(
  283|      8|            Arg::new("log_filename")
  284|      8|                .long("log-filename")
  285|      8|                .help("Log filename prefix")
  286|      8|                .default_value("qbittorrent-mcp-rs.log"),
  287|       |        )
  288|      8|        .arg(
  289|      8|            Arg::new("log_rotate")
  290|      8|                .long("log-rotate")
  291|      8|                .help("Log rotation strategy (daily, hourly, never)")
  292|      8|                .default_value("daily"),
  293|       |        )
  294|      8|        .arg(
  295|      8|            Arg::new("http_auth_token")
  296|      8|                .long("http-auth-token")
  297|      8|                .help("Authentication token for HTTP server mode"),
  298|       |        )
  299|      8|        .arg(
  300|      8|            Arg::new("polling_interval_ms")
  301|      8|                .long("polling-interval-ms")
  302|      8|                .help("Polling interval for notifications (ms)")
  303|      8|                .value_parser(clap::value_parser!(u64)),
  304|       |        );
  305|       |
  306|      8|    if args.is_empty() {
  307|      4|        cmd.get_matches_from(vec!["qbittorrent-mcp-rs"])
  308|       |    } else {
  309|      4|        cmd.get_matches_from(args)
  310|       |    }
  311|      8|}

/home/nicholas/git/nicholaswilde/qbittorrent-mcp-rs/src/main.rs:
    1|       |use qbittorrent_mcp_rs::config::AppConfig;
    2|       |use std::env;
    3|       |use tracing::{error, info};
    4|       |use tracing_appender::non_blocking::WorkerGuard;
    5|       |use tracing_appender::rolling::{RollingFileAppender, Rotation};
    6|       |use tracing_subscriber::{EnvFilter, Layer, layer::SubscriberExt, util::SubscriberInitExt};
    7|       |
    8|       |#[tokio::main]
    9|      1|async fn main() {
   10|      1|    match run().await {
   11|      1|        Ok(_) => {}
   12|      1|        Err(e) => {
                          ^0
   13|      1|            error!("Error: {}", e);
                          ^0
   14|      1|            std::process::exit(1);
                          ^0
   15|      1|        }
   16|      1|    }
   17|      1|}
   18|       |
   19|      1|async fn run() -> anyhow::Result<()> {
   20|      1|    let args: Vec<String> = env::args().collect();
   21|      1|    let config = AppConfig::load(None, args)?;
                                                          ^0
   22|       |
   23|       |    // Keep guard alive for the duration of the program
   24|      1|    let _guard = init_logging(&config);
   25|       |
   26|      1|    info!(
   27|       |        "Starting qBittorrent MCP Server in {} mode (lazy: {})",
   28|       |        config.server_mode, config.lazy_mode
   29|       |    );
   30|       |
   31|       |    use qbittorrent_mcp_rs::client::QBitClient;
   32|       |    use qbittorrent_mcp_rs::server::http::run_http_server;
   33|       |    use qbittorrent_mcp_rs::server::mcp::McpServer;
   34|       |    use std::collections::HashMap;
   35|       |
   36|      1|    let instances = config.get_instances();
   37|      1|    let mut clients = HashMap::new();
   38|       |
   39|      1|    for inst in instances {
   40|      1|        let base_url = if inst.host.starts_with("http://") || inst.host.starts_with("https://") {
   41|      0|            if let Some(port) = inst.port {
   42|      0|                format!("{}:{}", inst.host, port)
   43|       |            } else {
   44|      0|                inst.host.clone()
   45|       |            }
   46|       |        } else {
   47|      1|            let port = inst.port.unwrap_or(80);
   48|      1|            format!("http://{}:{}", inst.host, port)
   49|       |        };
   50|       |
   51|      1|        let no_verify_ssl =
   52|      1|            inst.no_verify_ssl.unwrap_or(config.no_verify_ssl) && base_url.starts_with("https://");
                                                                                ^0
   53|       |
   54|      1|        info!("Initializing client '{}' at {}", inst.name, base_url);
   55|       |
   56|      1|        let client = if let (Some(u), Some(p)) = (&inst.username, &inst.password) {
                                                ^0       ^0
   57|      0|            QBitClient::new(base_url, u, p, no_verify_ssl)
   58|       |        } else {
   59|      1|            QBitClient::new_no_auth(base_url, no_verify_ssl)
   60|       |        };
   61|       |
   62|      1|        if inst.username.is_some() {
   63|      0|            if let Err(e) = client.login().await {
   64|      0|                error!(
   65|       |                    "Failed to login to qBittorrent instance '{}': {}",
   66|       |                    inst.name, e
   67|       |                );
   68|       |            } else {
   69|      0|                info!(
   70|       |                    "Logged in to qBittorrent instance '{}' successfully",
   71|       |                    inst.name
   72|       |                );
   73|       |            }
   74|      1|        }
   75|      1|        clients.insert(inst.name, client);
   76|       |    }
   77|       |
   78|      1|    if clients.is_empty() {
   79|      0|        anyhow::bail!("No qBittorrent instances configured");
   80|      1|    }
   81|       |
   82|      1|    let mut server = McpServer::new(clients.clone(), config.lazy_mode);
   83|       |
   84|       |    // Spawn background polling task for notifications
   85|      1|    server.start_event_loop(config.polling_interval_ms);
   86|       |
   87|      1|    match config.server_mode.as_str() {
   88|      1|        "http" => {
   89|       |            // Hardcoded port 3000 for now as it was in the original main.rs
   90|      0|            run_http_server(server, "0.0.0.0", 3000, config.http_auth_token).await?;
   91|       |        }
   92|       |        _ => {
   93|      1|            server.run_stdio().await?;
                                                  ^0
   94|       |        }
   95|       |    };
   96|       |
   97|      1|    info!("Shutting down qBittorrent MCP Server");
   98|      1|    Ok(())
   99|      1|}
  100|       |
  101|      1|fn init_logging(config: &AppConfig) -> Option<WorkerGuard> {
  102|      1|    let filter_layer =
  103|      1|        EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(&config.log_level));
  104|       |
  105|      1|    let stdout_layer = tracing_subscriber::fmt::layer()
  106|      1|        .with_writer(std::io::stderr)
  107|      1|        .with_filter(filter_layer.clone());
  108|       |
  109|      1|    let (file_layer, guard) = if config.log_file_enable {
  110|      0|        let rotation = match config.log_rotate.to_lowercase().as_str() {
  111|      0|            "hourly" => Rotation::HOURLY,
  112|      0|            "never" => Rotation::NEVER,
  113|      0|            _ => Rotation::DAILY,
  114|       |        };
  115|       |
  116|      0|        let file_appender = RollingFileAppender::builder()
  117|      0|            .rotation(rotation)
  118|      0|            .filename_prefix(&config.log_filename)
  119|      0|            .build(&config.log_dir)
  120|      0|            .expect("Failed to create log file appender");
  121|       |
  122|      0|        let (non_blocking, guard) = tracing_appender::non_blocking(file_appender);
  123|       |
  124|      0|        (
  125|      0|            Some(
  126|      0|                tracing_subscriber::fmt::layer()
  127|      0|                    .with_writer(non_blocking)
  128|      0|                    .with_ansi(false)
  129|      0|                    .with_filter(filter_layer),
  130|      0|            ),
  131|      0|            Some(guard),
  132|      0|        )
  133|       |    } else {
  134|      1|        (None, None)
  135|       |    };
  136|       |
  137|      1|    let registry = tracing_subscriber::registry().with(stdout_layer);
  138|       |
  139|      1|    if let Some(layer) = file_layer {
                              ^0
  140|      0|        registry.with(layer).init();
  141|      1|    } else {
  142|      1|        registry.init();
  143|      1|    }
  144|       |
  145|      1|    guard
  146|      1|}

/home/nicholas/git/nicholaswilde/qbittorrent-mcp-rs/src/models.rs:
    1|       |use serde::{Deserialize, Serialize};
    2|       |
    3|       |#[derive(Debug, Serialize, Deserialize, Clone)]
    4|       |pub struct Torrent {
    5|       |    pub hash: String,
    6|       |    pub name: String,
    7|       |    #[serde(rename = "size")]
    8|       |    pub size_bytes: i64,
    9|       |    pub progress: f64,
   10|       |    pub dlspeed: i64,
   11|       |    pub upspeed: i64,
   12|       |    pub priority: i64,
   13|       |    #[serde(rename = "num_seeds")]
   14|       |    pub num_seeds: i64,
   15|       |    #[serde(rename = "num_leechs")]
   16|       |    pub num_leechs: i64,
   17|       |    #[serde(rename = "num_incomplete")]
   18|       |    pub num_incomplete: i64,
   19|       |    #[serde(rename = "num_complete")]
   20|       |    pub num_complete: i64,
   21|       |    pub ratio: f64,
   22|       |    pub eta: i64,
   23|       |    pub state: String,
   24|       |    pub added_on: i64,
   25|       |    pub completion_on: i64,
   26|       |    pub seq_dl: bool,
   27|       |    pub f_l_piece_prio: bool,
   28|       |    pub category: String,
   29|       |    pub tags: String,
   30|       |    pub super_seeding: bool,
   31|       |    pub force_start: bool,
   32|       |}
   33|       |
   34|       |#[derive(Debug, Serialize, Deserialize, Clone)]
   35|       |pub struct TorrentFile {
   36|       |    pub index: i64,
   37|       |    pub name: String,
   38|       |    pub size: i64,
   39|       |    pub progress: f64,
   40|       |    pub priority: i64,
   41|       |    pub is_seed: Option<bool>,
   42|       |    pub piece_range: Option<Vec<i64>>,
   43|       |    pub availability: f64,
   44|       |}
   45|       |
   46|       |#[derive(Debug, Serialize, Deserialize, Clone)]
   47|       |pub struct TorrentProperties {
   48|       |    pub save_path: String,
   49|       |    pub creation_date: i64,
   50|       |    pub piece_size: i64,
   51|       |    pub comment: String,
   52|       |    pub total_wasted: i64,
   53|       |    pub total_uploaded: i64,
   54|       |    pub total_downloaded: i64,
   55|       |    pub up_limit: i64,
   56|       |    pub dl_limit: i64,
   57|       |    pub time_elapsed: i64,
   58|       |    pub seeding_time: i64,
   59|       |    pub nb_connections: i64,
   60|       |    pub nb_connections_limit: i64,
   61|       |    pub share_ratio: f64,
   62|       |    pub addition_date: i64,
   63|       |    pub completion_date: i64,
   64|       |    pub created_by: String,
   65|       |    pub dl_speed_avg: i64,
   66|       |    pub dl_speed: i64,
   67|       |    pub eta: i64,
   68|       |    pub last_seen: i64,
   69|       |    pub peers: i64,
   70|       |    pub peers_total: i64,
   71|       |    pub pieces_have: i64,
   72|       |    pub pieces_num: i64,
   73|       |    pub reannounce: i64,
   74|       |    pub seeds: i64,
   75|       |    pub seeds_total: i64,
   76|       |    pub total_size: i64,
   77|       |    pub up_speed_avg: i64,
   78|       |    pub up_speed: i64,
   79|       |}
   80|       |
   81|       |#[derive(Debug, Serialize, Deserialize, Clone)]
   82|       |pub struct Tracker {
   83|       |    pub url: String,
   84|       |    pub status: i64, // 0: Disabled, 1: Not contacted, 2: Working, 3: Updating, 4: Not working
   85|       |    pub tier: i64,
   86|       |    pub num_peers: i64,
   87|       |    pub num_seeds: i64,
   88|       |    pub num_leeches: i64,
   89|       |    pub num_downloaded: i64,
   90|       |    pub msg: String,
   91|       |}
   92|       |
   93|       |#[derive(Debug, Serialize, Deserialize, Clone)]
   94|       |pub struct TransferInfo {
   95|       |    pub dl_info_speed: i64,
   96|       |    pub dl_info_data: i64,
   97|       |    pub up_info_speed: i64,
   98|       |    pub up_info_data: i64,
   99|       |    pub dl_rate_limit: i64,
  100|       |    pub up_rate_limit: i64,
  101|       |    pub dht_nodes: i64,
  102|       |    pub connection_status: String,
  103|       |}
  104|       |
  105|       |#[derive(Debug, Serialize, Deserialize, Clone)]
  106|       |pub struct SearchResult {
  107|       |    #[serde(rename = "fileName")]
  108|       |    pub file_name: String,
  109|       |    #[serde(rename = "fileUrl")]
  110|       |    pub file_url: String,
  111|       |    #[serde(rename = "fileSize")]
  112|       |    pub file_size: i64,
  113|       |    #[serde(rename = "nbSeeders")]
  114|       |    pub nb_seeders: i64,
  115|       |    #[serde(rename = "nbLeechers")]
  116|       |    pub nb_leechers: i64,
  117|       |    #[serde(rename = "siteUrl")]
  118|       |    pub site_url: String,
  119|       |}
  120|       |
  121|       |#[derive(Debug, Serialize, Deserialize, Clone)]
  122|       |pub struct SearchJob {
  123|       |    pub id: i64,
  124|       |}
  125|       |
  126|       |#[derive(Debug, Serialize, Deserialize, Clone)]
  127|       |pub struct SearchStatus {
  128|       |    pub id: i64,
  129|       |    pub status: String, // "Running", "Stopped"
  130|       |    pub total: i64,
  131|       |}
  132|       |
  133|       |#[derive(Debug, Serialize, Deserialize, Clone)]
  134|       |pub struct SearchResultsResponse {
  135|       |    pub results: Vec<SearchResult>,
  136|       |    pub status: String,
  137|       |    pub total: i64,
  138|       |}
  139|       |
  140|       |#[derive(Debug, Serialize, Deserialize, Clone)]
  141|       |pub struct Category {
  142|       |    pub name: String,
  143|       |    #[serde(rename = "savePath")]
  144|       |    pub save_path: String,
  145|       |}
  146|       |
  147|       |#[derive(Debug, Serialize, Deserialize, Clone)]
  148|       |pub struct SearchPlugin {
  149|       |    pub name: String,
  150|       |    #[serde(rename = "fullName")]
  151|       |    pub full_name: Option<String>,
  152|       |    pub version: Option<String>,
  153|       |    pub url: Option<String>,
  154|       |    pub supported_categories: Option<Vec<String>>,
  155|       |    pub enabled: bool,
  156|       |}
  157|       |
  158|       |#[derive(Debug, Serialize, Deserialize, Clone)]
  159|       |pub struct RssItem {
  160|       |    pub title: String,
  161|       |    pub url: String,
  162|       |}
  163|       |
  164|       |#[derive(Debug, Serialize, Deserialize, Clone)]
  165|       |pub struct RssFeed {
  166|       |    pub uid: String,
  167|       |    pub url: String,
  168|       |    pub title: String,
  169|       |    pub last_build_date: Option<String>,
  170|       |    pub items: Vec<RssItem>,
  171|       |}
  172|       |
  173|       |#[derive(Debug, Serialize, Deserialize, Clone)]
  174|       |#[serde(rename_all = "camelCase")]
  175|       |pub struct RssRule {
  176|       |    pub enabled: bool,
  177|       |    #[serde(default)]
  178|       |    pub must_contain: String,
  179|       |    #[serde(default)]
  180|       |    pub must_not_contain: String,
  181|       |    #[serde(default)]
  182|       |    pub use_regex: bool,
  183|       |    #[serde(default)]
  184|       |    pub episode_filter: String,
  185|       |    #[serde(default)]
  186|       |    pub smart_episode_filter: bool,
  187|       |    #[serde(default)]
  188|       |    pub assign_category: String,
  189|       |    pub add_paused: Option<bool>,
  190|       |    #[serde(default)]
  191|       |    pub save_path: String,
  192|       |}
  193|       |
  194|       |#[derive(Debug, Serialize, Deserialize, Clone)]
  195|       |pub struct LogEntry {
  196|       |    pub id: i64,
  197|       |    pub message: String,
  198|       |    pub timestamp: i64,
  199|       |    #[serde(rename = "type")]
  200|       |    pub severity: i64, // 1: Normal, 2: Info, 4: Warning, 8: Critical
  201|       |}
  202|       |
  203|       |#[derive(Debug, Serialize, Deserialize, Clone)]
  204|       |pub struct PeerLogEntry {
  205|       |    pub id: i64,
  206|       |    pub ip: String,
  207|       |    pub timestamp: i64,
  208|       |    pub blocked: bool,
  209|       |    pub reason: String,
  210|       |}
  211|       |
  212|       |#[derive(Debug, Serialize, Deserialize, Clone)]
  213|       |pub struct BuildInfo {
  214|       |    pub qt: String,
  215|       |    pub libtorrent: String,
  216|       |    pub boost: String,
  217|       |    pub openssl: String,
  218|       |    pub bitness: i64,
  219|       |}
  220|       |
  221|       |#[derive(Debug, Serialize, Deserialize, Clone)]
  222|       |pub struct SyncMainData {
  223|       |    pub rid: i64,
  224|       |    pub full_update: Option<bool>,
  225|       |    pub torrents: Option<std::collections::HashMap<String, serde_json::Value>>,
  226|       |    pub torrents_removed: Option<Vec<String>>,
  227|       |    pub categories: Option<std::collections::HashMap<String, Category>>,
  228|       |    pub categories_removed: Option<Vec<String>>,
  229|       |    pub tags: Option<Vec<String>>,
  230|       |    pub tags_removed: Option<Vec<String>>,
  231|       |    pub server_state: Option<serde_json::Value>,
  232|       |}
  233|       |
  234|       |#[cfg(test)]
  235|       |mod tests {
  236|       |    use super::*;
  237|       |
  238|       |    #[test]
  239|      1|    fn test_deserialize_torrent() {
  240|      1|        let json = r#"
  241|      1|        {
  242|      1|            "added_on": 1500000000,
  243|      1|            "amount_left": 0,
  244|      1|            "auto_tmm": false,
  245|      1|            "availability": 2,
  246|      1|            "category": "ISOs",
  247|      1|            "completed": 1000,
  248|      1|            "completion_on": 1500000500,
  249|      1|            "content_path": "/downloads/Ubuntu.iso",
  250|      1|            "dl_limit": -1,
  251|      1|            "dlspeed": 5000,
  252|      1|            "downloaded": 1000,
  253|      1|            "downloaded_session": 1000,
  254|      1|            "eta": 3600,
  255|      1|            "f_l_piece_prio": false,
  256|      1|            "force_start": false,
  257|      1|            "hash": "8c4a5c5b5d5e5f5g5h5i5j5k5l5m5n5o5p5q5r5s",
  258|      1|            "last_activity": 1500001000,
  259|      1|            "magnet_uri": "magnet:?xt=urn:btih:...",
  260|      1|            "max_ratio": -1,
  261|      1|            "max_seeding_time": -1,
  262|      1|            "name": "Ubuntu Linux",
  263|      1|            "num_complete": 10,
  264|      1|            "num_incomplete": 5,
  265|      1|            "num_leechs": 5,
  266|      1|            "num_seeds": 10,
  267|      1|            "priority": 1,
  268|      1|            "progress": 0.5,
  269|      1|            "ratio": 1.5,
  270|      1|            "ratio_limit": -2,
  271|      1|            "save_path": "/downloads/",
  272|      1|            "seeding_time": 600,
  273|      1|            "seeding_time_limit": -2,
  274|      1|            "seen_complete": 1500000500,
  275|      1|            "seq_dl": false,
  276|      1|            "size": 2000000000,
  277|      1|            "state": "downloading",
  278|      1|            "super_seeding": false,
  279|      1|            "tags": "linux,iso",
  280|      1|            "time_active": 1000,
  281|      1|            "total_size": 2000000000,
  282|      1|            "tracker": "http://tracker.example.com",
  283|      1|            "up_limit": -1,
  284|      1|            "uploaded": 500,
  285|      1|            "uploaded_session": 500,
  286|      1|            "upspeed": 1000
  287|      1|        }
  288|      1|        "#;
  289|       |
  290|      1|        let torrent: Torrent = serde_json::from_str(json).expect("Failed to deserialize torrent");
  291|       |
  292|      1|        assert_eq!(torrent.hash, "8c4a5c5b5d5e5f5g5h5i5j5k5l5m5n5o5p5q5r5s");
  293|      1|        assert_eq!(torrent.name, "Ubuntu Linux");
  294|      1|        assert_eq!(torrent.size_bytes, 2000000000);
  295|      1|        assert_eq!(torrent.state, "downloading");
  296|      1|        assert_eq!(torrent.progress, 0.5);
  297|      1|    }
  298|       |}

/home/nicholas/git/nicholaswilde/qbittorrent-mcp-rs/src/server/http.rs:
    1|       |#![allow(clippy::collapsible_if)]
    2|       |use axum::http::StatusCode;
    3|       |use axum::{
    4|       |    Json, Router,
    5|       |    extract::{Query, Request, State},
    6|       |    middleware::{self, Next},
    7|       |    response::{
    8|       |        IntoResponse, Response,
    9|       |        sse::{Event, Sse},
   10|       |    },
   11|       |    routing::{get, post},
   12|       |};
   13|       |use dashmap::DashMap;
   14|       |use futures::stream::Stream;
   15|       |use serde::Deserialize;
   16|       |use std::{collections::HashMap, convert::Infallible, sync::Arc, time::Duration};
   17|       |use tokio::sync::mpsc;
   18|       |use tokio_stream::wrappers::ReceiverStream;
   19|       |use tower_http::{cors::CorsLayer, trace::TraceLayer};
   20|       |use tracing::{debug, error, info};
   21|       |use uuid::Uuid;
   22|       |
   23|       |use crate::server::mcp::{JsonRpcError, JsonRpcRequest, JsonRpcResponse, McpServer};
   24|       |
   25|       |#[derive(Clone)]
   26|       |struct AppState {
   27|       |    mcp_server: McpServer,
   28|       |    sessions: Arc<DashMap<String, mpsc::Sender<Result<Event, Infallible>>>>,
   29|       |    auth_token: Option<String>,
   30|       |}
   31|       |
   32|       |#[derive(Deserialize)]
   33|       |struct MessageParams {
   34|       |    session_id: String,
   35|       |}
   36|       |
   37|      7|pub async fn create_router(mcp_server: McpServer, auth_token: Option<String>) -> Router {
   38|      7|    let state = AppState {
   39|      7|        mcp_server,
   40|      7|        sessions: Arc::new(DashMap::new()),
   41|      7|        auth_token,
   42|      7|    };
   43|       |
   44|      7|    Router::new()
   45|      7|        .route("/sse", get(sse_handler))
   46|      7|        .route("/message", post(message_handler))
   47|      7|        .layer(middleware::from_fn_with_state(
   48|      7|            state.clone(),
   49|       |            auth_middleware,
   50|       |        ))
   51|      7|        .layer(CorsLayer::permissive())
   52|      7|        .layer(TraceLayer::new_for_http())
   53|      7|        .with_state(state)
   54|      7|}
   55|       |
   56|      1|pub async fn run_http_server(
   57|      1|    mcp_server: McpServer,
   58|      1|    host: &str,
   59|      1|    port: u16,
   60|      1|    auth_token: Option<String>,
   61|      1|) -> anyhow::Result<()> {
   62|      1|    let app = create_router(mcp_server, auth_token).await;
   63|       |
   64|      1|    let addr = format!("{}:{}", host, port);
   65|      1|    info!("Starting HTTP MCP Server on {}", addr);
   66|       |
   67|      1|    let listener = tokio::net::TcpListener::bind(&addr).await?;
                                                                           ^0
   68|      1|    axum::serve(listener, app).await?;
                                                  ^0
   69|       |
   70|      0|    Ok(())
   71|      0|}
   72|       |
   73|      6|async fn sse_handler(
   74|      6|    State(state): State<AppState>,
   75|      6|) -> Sse<impl Stream<Item = Result<Event, Infallible>>> {
   76|      6|    let session_id = Uuid::new_v4().to_string();
   77|      6|    let (tx, rx) = mpsc::channel(100);
   78|       |
   79|      6|    state.sessions.insert(session_id.clone(), tx.clone());
   80|       |
   81|      6|    info!("New SSE session connected: {}", session_id);
   82|       |
   83|       |    // Send the endpoint event immediately
   84|      6|    let endpoint_url = format!("/message?session_id={}", session_id);
   85|      6|    let _ = tx
   86|      6|        .send(Ok(Event::default().event("endpoint").data(endpoint_url)))
   87|      6|        .await;
   88|       |
   89|       |    // Create a stream that removes the session on drop
   90|      6|    let stream = ReceiverStream::new(rx);
   91|       |
   92|      6|    Sse::new(stream)
   93|      6|        .keep_alive(axum::response::sse::KeepAlive::new().interval(Duration::from_secs(15)))
   94|      6|}
   95|       |
   96|      3|async fn message_handler(
   97|      3|    State(state): State<AppState>,
   98|      3|    Query(params): Query<MessageParams>,
   99|      3|    Json(req): Json<JsonRpcRequest>,
  100|      3|) -> impl IntoResponse {
  101|      3|    let session_id = params.session_id;
  102|       |
  103|      3|    let tx = if let Some(sender) = state.sessions.get(&session_id) {
                      ^2               ^2
  104|      2|        sender.clone()
  105|       |    } else {
  106|      1|        return (axum::http::StatusCode::NOT_FOUND, "Session not found").into_response();
  107|       |    };
  108|       |
  109|      2|    let mcp = state.mcp_server.clone();
  110|       |
  111|      2|    tokio::spawn(async move {
  112|      2|        let req_id = req.id.clone();
  113|      2|        debug!(
  114|       |            "Received HTTP request for session {}: {:?}",
  115|       |            session_id, req
  116|       |        );
  117|       |
  118|      2|        let resp = mcp.handle_request(req).await;
  119|       |
  120|      2|        if let Some(id) = req_id {
  121|      2|            let json_resp = match resp {
  122|      1|                Ok(result) => JsonRpcResponse {
  123|      1|                    jsonrpc: "2.0".to_string(),
  124|      1|                    id: Some(id),
  125|      1|                    result: Some(result),
  126|      1|                    error: None,
  127|      1|                },
  128|      1|                Err(e) => JsonRpcResponse {
  129|      1|                    jsonrpc: "2.0".to_string(),
  130|      1|                    id: Some(id),
  131|      1|                    result: None,
  132|      1|                    error: Some(JsonRpcError {
  133|      1|                        code: -32603,
  134|      1|                        message: e.to_string(),
  135|      1|                        data: None,
  136|      1|                    }),
  137|      1|                },
  138|       |            };
  139|       |
  140|      2|            if let Ok(data) = serde_json::to_string(&json_resp) {
  141|       |                // Send response as 'message' event
  142|      2|                if let Err(e) = tx
                                         ^0
  143|      2|                    .send(Ok(Event::default().event("message").data(data)))
  144|      2|                    .await
  145|       |                {
  146|      0|                    error!("Failed to send SSE event to session {}: {}", session_id, e);
  147|      2|                }
  148|      0|            }
  149|       |
  150|       |            // Check for notifications
  151|      2|            if mcp.check_notification() {
  152|      0|                let notification = serde_json::json!({
  153|      0|                    "jsonrpc": "2.0",
  154|      0|                    "method": "notifications/tools/list_changed"
  155|       |                });
  156|      0|                if let Ok(data) = serde_json::to_string(&notification) {
  157|      0|                    if let Err(e) = tx
  158|      0|                        .send(Ok(Event::default().event("message").data(data)))
  159|      0|                        .await
  160|       |                    {
  161|      0|                        error!(
  162|       |                            "Failed to send notification to session {}: {}",
  163|       |                            session_id, e
  164|       |                        );
  165|      0|                    }
  166|      0|                }
  167|      2|            }
  168|      0|        }
  169|      2|    });
  170|       |
  171|       |    // Return 202 Accepted immediately
  172|      2|    (axum::http::StatusCode::ACCEPTED, "Accepted").into_response()
  173|      3|}
  174|       |
  175|     11|async fn auth_middleware(
  176|     11|    State(state): State<AppState>,
  177|     11|    req: Request,
  178|     11|    next: Next,
  179|     11|) -> Result<Response, StatusCode> {
  180|     11|    if let Some(ref token) = state.auth_token {
                              ^3
  181|       |        // 1. Check Header
  182|      3|        if let Some(auth_header) = req.headers().get("Authorization") {
                                  ^1
  183|      1|            if let Ok(auth_str) = auth_header.to_str() {
  184|      1|                if auth_str == format!("Bearer {}", token) {
  185|      1|                    return Ok(next.run(req).await);
  186|      0|                }
  187|      0|            }
  188|      2|        }
  189|       |
  190|       |        // 2. Check Query Param
  191|      2|        if let Some(query) = req.uri().query() {
                                  ^1
  192|      1|            let params: HashMap<String, String> = url::form_urlencoded::parse(query.as_bytes())
  193|      1|                .into_owned()
  194|      1|                .collect();
  195|       |
  196|      1|            if let Some(t) = params.get("token") {
  197|      1|                if t == token {
  198|      1|                    return Ok(next.run(req).await);
  199|      0|                }
  200|      0|            }
  201|      1|        }
  202|       |
  203|      1|        return Err(StatusCode::UNAUTHORIZED);
  204|      8|    }
  205|       |
  206|      8|    Ok(next.run(req).await)
  207|     11|}

/home/nicholas/git/nicholaswilde/qbittorrent-mcp-rs/src/server/mcp.rs:
    1|       |use crate::client::QBitClient;
    2|       |use anyhow::Result;
    3|       |use regex::Regex;
    4|       |use serde::{Deserialize, Serialize};
    5|       |use serde_json::{Value, json};
    6|       |use std::collections::HashMap;
    7|       |use std::sync::{Arc, Mutex};
    8|       |use std::time::Duration;
    9|       |use tokio::time::sleep;
   10|       |use tracing::{debug, error, info};
   11|       |
   12|       |#[derive(Serialize, Deserialize, Debug)]
   13|       |pub struct JsonRpcRequest {
   14|       |    pub jsonrpc: String,
   15|       |    pub method: String,
   16|       |    pub params: Option<Value>,
   17|       |    pub id: Option<Value>,
   18|       |}
   19|       |
   20|       |#[derive(Serialize, Deserialize, Debug)]
   21|       |pub struct JsonRpcResponse {
   22|       |    pub jsonrpc: String,
   23|       |    pub id: Option<Value>,
   24|       |    #[serde(skip_serializing_if = "Option::is_none")]
   25|       |    pub result: Option<Value>,
   26|       |    #[serde(skip_serializing_if = "Option::is_none")]
   27|       |    pub error: Option<JsonRpcError>,
   28|       |}
   29|       |
   30|       |#[derive(Serialize, Deserialize, Debug)]
   31|       |pub struct JsonRpcError {
   32|       |    pub code: i64,
   33|       |    pub message: String,
   34|       |    #[serde(skip_serializing_if = "Option::is_none")]
   35|       |    pub data: Option<Value>,
   36|       |}
   37|       |
   38|       |struct McpState {
   39|       |    lazy_mode: bool,
   40|       |    tools_loaded: bool,
   41|       |    should_notify: bool,
   42|       |    notification_queue: Vec<Value>,
   43|       |}
   44|       |
   45|       |#[derive(Clone)]
   46|       |pub struct McpServer {
   47|       |    clients: HashMap<String, QBitClient>,
   48|       |    state: Arc<Mutex<McpState>>,
   49|       |}
   50|       |
   51|       |impl McpServer {
   52|     16|    pub fn new(clients: HashMap<String, QBitClient>, lazy_mode: bool) -> Self {
   53|     16|        Self {
   54|     16|            clients,
   55|     16|            state: Arc::new(Mutex::new(McpState {
   56|     16|                lazy_mode,
   57|     16|                tools_loaded: !lazy_mode,
   58|     16|                should_notify: false,
   59|     16|                notification_queue: Vec::new(),
   60|     16|            })),
   61|     16|        }
   62|     16|    }
   63|       |
   64|      3|    pub fn push_notification(&self, method: &str, params: Value) {
   65|      3|        let mut state = self.state.lock().unwrap();
   66|      3|        state.notification_queue.push(json!({
   67|      3|            "jsonrpc": "2.0",
   68|      3|            "method": method,
   69|      3|            "params": params
   70|       |        }));
   71|      3|    }
   72|       |
   73|      4|    async fn flush_notifications_async<W: tokio::io::AsyncWrite + Unpin>(
   74|      4|        &self,
   75|      4|        writer: &mut W,
   76|      4|    ) -> Result<()> {
   77|       |        use tokio::io::AsyncWriteExt;
   78|       |
   79|      4|        let mut pending = Vec::new();
   80|       |        {
   81|      4|            let mut state = self.state.lock().unwrap();
   82|      4|            if state.should_notify {
   83|      0|                state.should_notify = false;
   84|      0|                pending.push(json!({
   85|      0|                    "jsonrpc": "2.0",
   86|      0|                    "method": "notifications/tools/list_changed"
   87|      0|                }));
   88|      4|            }
   89|      4|            while !state.notification_queue.is_empty() {
   90|      0|                pending.push(state.notification_queue.remove(0));
   91|      0|            }
   92|       |        }
   93|       |
   94|      4|        for n in pending {
                          ^0
   95|      0|            let out = serde_json::to_string(&n)? + "\n";
   96|      0|            writer.write_all(out.as_bytes()).await?;
   97|       |        }
   98|      4|        writer.flush().await?;
                                          ^0
   99|      4|        Ok(())
  100|      4|    }
  101|       |
  102|     60|    fn get_client(&self, instance: Option<&str>) -> Result<&QBitClient> {
  103|     60|        if let Some(name) = instance {
                                  ^3
  104|      3|            self.clients
  105|      3|                .get(name)
  106|      3|                .ok_or_else(|| anyhow::anyhow!("Instance not found: {}", name))
                                             ^0
  107|       |        } else {
  108|       |            // Use "default" if exists, otherwise first one
  109|     57|            if let Some(client) = self.clients.get("default") {
  110|     57|                Ok(client)
  111|       |            } else {
  112|      0|                self.clients
  113|      0|                    .values()
  114|      0|                    .next()
  115|      0|                    .ok_or_else(|| anyhow::anyhow!("No instances configured"))
  116|       |            }
  117|       |        }
  118|     60|    }
  119|       |
  120|      2|    pub fn check_notification(&self) -> bool {
  121|      2|        let mut state = self.state.lock().unwrap();
  122|      2|        if state.should_notify {
  123|      0|            state.should_notify = false;
  124|      0|            true
  125|       |        } else {
  126|      2|            false
  127|       |        }
  128|      2|    }
  129|       |
  130|      1|    pub async fn run_stdio(&mut self) -> Result<()> {
  131|       |        use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader, stdin, stdout};
  132|      1|        let mut reader = BufReader::new(stdin()).lines();
  133|      1|        let mut stdout = stdout();
  134|       |
  135|       |        loop {
  136|      5|            tokio::select! {
  137|      5|                line_res = reader.next_line() => {
  138|      5|                    let line = match line_res? {
                                      ^4                   ^0
  139|      4|                        Some(l) => l,
  140|      1|                        None => break, // EOF
  141|       |                    };
  142|      4|                    let input = line.trim();
  143|      4|                    if input.is_empty() {
  144|      0|                        continue;
  145|      4|                    }
  146|       |
  147|      4|                    debug!("Received: {}", input);
  148|       |
  149|      4|                    match serde_json::from_str::<JsonRpcRequest>(input) {
  150|      4|                        Ok(req) => {
  151|      4|                            let id = req.id.clone();
  152|      4|                            let resp = self.handle_request(req).await;
  153|       |
  154|      4|                            if let Some(req_id) = id {
                                                      ^3
  155|      3|                                let json_resp = match resp {
  156|      3|                                    Ok(result) => JsonRpcResponse {
  157|      3|                                        jsonrpc: "2.0".to_string(),
  158|      3|                                        id: Some(req_id),
  159|      3|                                        result: Some(result),
  160|      3|                                        error: None,
  161|      3|                                    },
  162|      0|                                    Err(e) => JsonRpcResponse {
  163|      0|                                        jsonrpc: "2.0".to_string(),
  164|      0|                                        id: Some(req_id),
  165|      0|                                        result: None,
  166|      0|                                        error: Some(JsonRpcError {
  167|      0|                                            code: -32603,
  168|      0|                                            message: e.to_string(),
  169|      0|                                            data: None,
  170|      0|                                        }),
  171|      0|                                    },
  172|       |                                };
  173|       |
  174|      3|                                let out = serde_json::to_string(&json_resp)? + "\n";
                                                                                         ^0
  175|      3|                                stdout.write_all(out.as_bytes()).await?;
                                                                                    ^0
  176|      3|                                stdout.flush().await?;
                                                                  ^0
  177|       |                            } else {
  178|       |                                // Notification, no response expected
  179|      1|                                if let Err(e) = resp {
                                                         ^0
  180|      0|                                    error!("Error handling notification: {}", e);
  181|      1|                                }
  182|       |                            }
  183|       |                        }
  184|      0|                        Err(e) => {
  185|      0|                            error!("Failed to parse JSON-RPC: {}", e);
  186|       |                        }
  187|       |                    }
  188|      4|                    self.flush_notifications_async(&mut stdout).await?;
                                                                                   ^0
  189|       |                }
  190|      5|                _ = sleep(Duration::from_millis(500)) => {
  191|      0|                    self.flush_notifications_async(&mut stdout).await?;
  192|       |                }
  193|       |            }
  194|       |        }
  195|      1|        Ok(())
  196|      1|    }
  197|       |
  198|     68|    pub async fn handle_request(&self, req: JsonRpcRequest) -> Result<Value> {
  199|     68|        match req.method.as_str() {
  200|     68|            "initialize" => Ok(json!({
                                          ^1 ^1
  201|      1|                "protocolVersion": "2024-11-05",
  202|      1|                "serverInfo": {
  203|      1|                    "name": "qbittorrent-mcp-rs",
  204|      1|                    "version": env!("CARGO_PKG_VERSION")
  205|      1|                },
  206|      1|                "capabilities": {
  207|      1|                    "tools": {
  208|      1|                        "listChanged": true
  209|      1|                    },
  210|      1|                    "resources": {
  211|      1|                        "listChanged": false,
  212|      1|                        "subscribe": false
  213|      1|                    },
  214|      1|                    "prompts": {
  215|      1|                        "listChanged": false
  216|      1|                    }
  217|      1|                }
  218|      1|            })),
  219|     67|            "notifications/initialized" => {
  220|      1|                info!("Client initialized");
  221|      1|                Ok(Value::Null)
  222|       |            }
  223|     66|            "ping" => Ok(json!({})),
                                    ^1
  224|     65|            "prompts/list" => Ok(json!({
                                            ^1 ^1
  225|      1|                "prompts": self.get_prompt_definitions()
  226|      1|            })),
  227|     64|            "prompts/get" => {
  228|      2|                if let Some(params) = req.params {
                                          ^1
  229|      1|                    let name = params.get("name").and_then(|n| n.as_str()).unwrap_or("");
  230|      1|                    let args = params.get("arguments").unwrap_or(&Value::Null);
  231|      1|                    self.handle_prompt_get(name, args).await
  232|       |                } else {
  233|      1|                    anyhow::bail!("Missing params for prompts/get");
  234|       |                }
  235|       |            }
  236|     62|            "tools/list" => Ok(json!({
                                          ^1 ^1
  237|      1|                "tools": self.get_tool_definitions()
  238|      1|            })),
  239|     61|            "tools/call" => {
  240|     57|                if let Some(params) = req.params {
  241|     57|                    let name = params.get("name").and_then(|n| n.as_str()).unwrap_or("");
  242|     57|                    let args = params.get("arguments").unwrap_or(&Value::Null);
  243|     57|                    self.call_tool(name, args).await
  244|       |                } else {
  245|      0|                    anyhow::bail!("Missing params for tools/call");
  246|       |                }
  247|       |            }
  248|      4|            "resources/list" => Ok(json!({
                                              ^0 ^0
  249|      0|                "resources": self.get_resource_definitions()
  250|      0|            })),
  251|      4|            "resources/read" => {
  252|      3|                if let Some(params) = req.params {
  253|      3|                    let uri = params.get("uri").and_then(|n| n.as_str()).unwrap_or("");
  254|      3|                    self.handle_resource_read(uri).await
  255|       |                } else {
  256|      0|                    anyhow::bail!("Missing params for resources/read");
  257|       |                }
  258|       |            }
  259|       |            _ => {
  260|      1|                anyhow::bail!("Method not found: {}", req.method);
  261|       |            }
  262|       |        }
  263|     68|    }
  264|       |
  265|      1|    fn get_resource_definitions(&self) -> Vec<Value> {
  266|      1|        let mut res = Vec::new();
  267|      1|        for name in self.clients.keys() {
  268|      1|            res.push(json!({
  269|      1|                "uri": format!("qbittorrent://{}/torrents", name),
  270|      1|                "name": format!("Torrent List ({})", name),
  271|      1|                "description": format!("A live list of all torrents on instance: {}", name),
  272|      1|                "mimeType": "application/json"
  273|      1|            }));
  274|      1|            res.push(json!({
  275|      1|                "uri": format!("qbittorrent://{}/transfer", name),
  276|      1|                "name": format!("Global Transfer Info ({})", name),
  277|      1|                "description": format!("Current speeds and limits on instance: {}", name),
  278|      1|                "mimeType": "application/json"
  279|      1|            }));
  280|      1|            res.push(json!({
  281|      1|                "uri": format!("qbittorrent://{}/categories", name),
  282|      1|                "name": format!("Categories ({})", name),
  283|      1|                "description": format!("All defined categories on instance: {}", name),
  284|      1|                "mimeType": "application/json"
  285|      1|            }));
  286|      1|        }
  287|       |
  288|       |        // Templates
  289|      1|        res.push(json!({
  290|      1|            "uriTemplate": "qbittorrent://{instance}/torrent/{hash}/properties",
  291|      1|            "name": "Torrent Properties",
  292|      1|            "description": "Detailed properties and metadata for a specific torrent",
  293|      1|            "mimeType": "application/json"
  294|       |        }));
  295|      1|        res.push(json!({
  296|      1|            "uriTemplate": "qbittorrent://{instance}/torrent/{hash}/files",
  297|      1|            "name": "Torrent Files",
  298|      1|            "description": "List of files and their progress within a specific torrent",
  299|      1|            "mimeType": "application/json"
  300|       |        }));
  301|      1|        res.push(json!({
  302|      1|            "uriTemplate": "qbittorrent://{instance}/torrent/{hash}/trackers",
  303|      1|            "name": "Torrent Trackers",
  304|      1|            "description": "Current trackers and their status for a specific torrent",
  305|      1|            "mimeType": "application/json"
  306|       |        }));
  307|      1|        res
  308|      1|    }
  309|       |
  310|      3|    async fn handle_resource_read(&self, uri: &str) -> Result<Value> {
  311|      3|        let re_torrents = Regex::new(r"qbittorrent://([^/]+)/torrents")?;
                                                                                     ^0
  312|      3|        let re_transfer = Regex::new(r"qbittorrent://([^/]+)/transfer")?;
                                                                                     ^0
  313|      3|        let re_categories = Regex::new(r"qbittorrent://([^/]+)/categories")?;
                                                                                         ^0
  314|      3|        let re_props = Regex::new(r"qbittorrent://([^/]+)/torrent/([^/]+)/properties")?;
                                                                                                    ^0
  315|      3|        let re_files = Regex::new(r"qbittorrent://([^/]+)/torrent/([^/]+)/files")?;
                                                                                               ^0
  316|      3|        let re_trackers = Regex::new(r"qbittorrent://([^/]+)/torrent/([^/]+)/trackers")?;
                                                                                                     ^0
  317|       |
  318|      3|        if let Some(caps) = re_torrents.captures(uri) {
                                  ^1
  319|      1|            let instance = &caps[1];
  320|      1|            let client = self.get_client(Some(instance))?;
                                                                      ^0
  321|      1|            let torrents = client
  322|      1|                .get_torrent_list(None, None, None, None, None, None, None)
  323|      1|                .await?;
                                    ^0
  324|      1|            let content = serde_json::to_string_pretty(&torrents)?;
                                                                               ^0
  325|      1|            return Ok(json!({
  326|      1|                "contents": [{
  327|      1|                    "uri": uri,
  328|      1|                    "mimeType": "application/json",
  329|      1|                    "text": content
  330|      1|                }]
  331|      1|            }));
  332|      2|        }
  333|       |
  334|      2|        if let Some(caps) = re_transfer.captures(uri) {
                                  ^1
  335|      1|            let instance = &caps[1];
  336|      1|            let client = self.get_client(Some(instance))?;
                                                                      ^0
  337|      1|            let info = client.get_global_transfer_info().await?;
                                                                            ^0
  338|      1|            let content = serde_json::to_string_pretty(&info)?;
                                                                           ^0
  339|      1|            return Ok(json!({
  340|      1|                "contents": [{
  341|      1|                    "uri": uri,
  342|      1|                    "mimeType": "application/json",
  343|      1|                    "text": content
  344|      1|                }]
  345|      1|            }));
  346|      1|        }
  347|       |
  348|      1|        if let Some(caps) = re_categories.captures(uri) {
  349|      1|            let instance = &caps[1];
  350|      1|            let client = self.get_client(Some(instance))?;
                                                                      ^0
  351|      1|            let categories = client.get_categories().await?;
                                                                        ^0
  352|      1|            let content = serde_json::to_string_pretty(&categories)?;
                                                                                 ^0
  353|      1|            return Ok(json!({
  354|      1|                "contents": [{
  355|      1|                    "uri": uri,
  356|      1|                    "mimeType": "application/json",
  357|      1|                    "text": content
  358|      1|                }]
  359|      1|            }));
  360|      0|        }
  361|       |
  362|      0|        if let Some(caps) = re_props.captures(uri) {
  363|      0|            let instance = &caps[1];
  364|      0|            let hash = &caps[2];
  365|      0|            let client = self.get_client(Some(instance))?;
  366|      0|            let props = client.get_torrent_properties(hash).await?;
  367|      0|            let content = serde_json::to_string_pretty(&props)?;
  368|      0|            return Ok(json!({
  369|      0|                "contents": [{
  370|      0|                    "uri": uri,
  371|      0|                    "mimeType": "application/json",
  372|      0|                    "text": content
  373|      0|                }]
  374|      0|            }));
  375|      0|        }
  376|       |
  377|      0|        if let Some(caps) = re_files.captures(uri) {
  378|      0|            let instance = &caps[1];
  379|      0|            let hash = &caps[2];
  380|      0|            let client = self.get_client(Some(instance))?;
  381|      0|            let files = client.get_torrent_files(hash).await?;
  382|      0|            let content = serde_json::to_string_pretty(&files)?;
  383|      0|            return Ok(json!({
  384|      0|                "contents": [{
  385|      0|                    "uri": uri,
  386|      0|                    "mimeType": "application/json",
  387|      0|                    "text": content
  388|      0|                }]
  389|      0|            }));
  390|      0|        }
  391|       |
  392|      0|        if let Some(caps) = re_trackers.captures(uri) {
  393|      0|            let instance = &caps[1];
  394|      0|            let hash = &caps[2];
  395|      0|            let client = self.get_client(Some(instance))?;
  396|      0|            let trackers = client.get_torrent_trackers(hash).await?;
  397|      0|            let content = serde_json::to_string_pretty(&trackers)?;
  398|      0|            return Ok(json!({
  399|      0|                "contents": [{
  400|      0|                    "uri": uri,
  401|      0|                    "mimeType": "application/json",
  402|      0|                    "text": content
  403|      0|                }]
  404|      0|            }));
  405|      0|        }
  406|       |
  407|       |        // Fallback for legacy URIs (without instance) - use default client
  408|      0|        match uri {
  409|      0|            "qbittorrent://torrents" => {
  410|      0|                let client = self.get_client(None)?;
  411|      0|                let torrents = client
  412|      0|                    .get_torrent_list(None, None, None, None, None, None, None)
  413|      0|                    .await?;
  414|      0|                let content = serde_json::to_string_pretty(&torrents)?;
  415|      0|                Ok(json!({
  416|      0|                    "contents": [{
  417|      0|                        "uri": uri,
  418|      0|                        "mimeType": "application/json",
  419|      0|                        "text": content
  420|      0|                    }]
  421|      0|                }))
  422|       |            }
  423|      0|            "qbittorrent://transfer" => {
  424|      0|                let client = self.get_client(None)?;
  425|      0|                let info = client.get_global_transfer_info().await?;
  426|      0|                let content = serde_json::to_string_pretty(&info)?;
  427|      0|                Ok(json!({
  428|      0|                    "contents": [{
  429|      0|                        "uri": uri,
  430|      0|                        "mimeType": "application/json",
  431|      0|                        "text": content
  432|      0|                    }]
  433|      0|                }))
  434|       |            }
  435|      0|            "qbittorrent://categories" => {
  436|      0|                let client = self.get_client(None)?;
  437|      0|                let categories = client.get_categories().await?;
  438|      0|                let content = serde_json::to_string_pretty(&categories)?;
  439|      0|                Ok(json!({
  440|      0|                    "contents": [{
  441|      0|                        "uri": uri,
  442|      0|                        "mimeType": "application/json",
  443|      0|                        "text": content
  444|      0|                    }]
  445|      0|                }))
  446|       |            }
  447|      0|            _ => anyhow::bail!("Resource not found: {}", uri),
  448|       |        }
  449|      3|    }
  450|       |
  451|      1|    fn get_prompt_definitions(&self) -> Vec<Value> {
  452|      1|        vec![
  453|      1|            json!({
  454|      1|                "name": "fix_stalled_torrent",
  455|      1|                "description": "Get instructions and context to troubleshoot a stalled or slow torrent",
  456|      1|                "arguments": [
  457|       |                    {
  458|      1|                        "name": "hash",
  459|      1|                        "description": "Torrent hash to troubleshoot",
  460|      1|                        "required": true
  461|       |                    },
  462|       |                    {
  463|      1|                        "name": "instance",
  464|      1|                        "description": "Instance name (optional)",
  465|      1|                        "required": false
  466|       |                    }
  467|       |                ]
  468|       |            }),
  469|      1|            json!({
  470|      1|                "name": "analyze_disk_space",
  471|      1|                "description": "Check if there is enough disk space for current downloads",
  472|      1|                "arguments": [
  473|       |                    {
  474|      1|                        "name": "instance",
  475|      1|                        "description": "Instance name (optional)",
  476|      1|                        "required": false
  477|       |                    }
  478|       |                ]
  479|       |            }),
  480|      1|            json!({
  481|      1|                "name": "optimize_speed",
  482|      1|                "description": "Suggest optimizations for slow downloads",
  483|      1|                "arguments": [
  484|       |                    {
  485|      1|                        "name": "instance",
  486|      1|                        "description": "Instance name (optional)",
  487|      1|                        "required": false
  488|       |                    }
  489|       |                ]
  490|       |            }),
  491|      1|            json!({
  492|      1|                "name": "troubleshoot_connection",
  493|      1|                "description": "Diagnose connection and connectivity issues",
  494|      1|                "arguments": [
  495|       |                    {
  496|      1|                        "name": "instance",
  497|      1|                        "description": "Instance name (optional)",
  498|      1|                        "required": false
  499|       |                    }
  500|       |                ]
  501|       |            }),
  502|      1|            json!({
  503|      1|                "name": "rules-of-engagement",
  504|      1|                "description": "Get the behavioral rules and best practices for interacting with this qBittorrent MCP server",
  505|      1|                "arguments": []
  506|       |            }),
  507|       |        ]
  508|      1|    }
  509|       |
  510|      1|    async fn handle_prompt_get(&self, name: &str, args: &Value) -> Result<Value> {
  511|      1|        let instance = args
  512|      1|            .get("instance")
  513|      1|            .and_then(|v| v.as_str())
                                        ^0^0
  514|      1|            .unwrap_or("default");
  515|       |
  516|      1|        match name {
  517|      1|            "fix_stalled_torrent" => {
  518|      0|                let hash = args
  519|      0|                    .get("hash")
  520|      0|                    .and_then(|v| v.as_str())
  521|      0|                    .ok_or(anyhow::anyhow!("Missing hash"))?;
  522|       |
  523|      0|                Ok(json!({
  524|      0|                    "description": format!("Troubleshooting for torrent {} on instance {}", hash, instance),
  525|      0|                    "messages": [
  526|      0|                        {
  527|      0|                            "role": "user",
  528|      0|                            "content": {
  529|      0|                                "type": "text",
  530|      0|                                "text": format!(
  531|      0|                                    "I have a torrent with hash '{}' on instance '{}' that is stalled or slow. \
  532|      0|                                     Please investigate it. Follow these steps:\n\
  533|      0|                                     1. Check the torrent properties using 'qbittorrent://{}/torrent/{}/properties'.\n\
  534|      0|                                     2. Check tracker status using 'qbittorrent://{}/torrent/{}/trackers'.\n\
  535|      0|                                     3. Check for specific file issues using 'qbittorrent://{}/torrent/{}/files'.\n\
  536|      0|                                     4. Look for global limits or mode using 'get_global_transfer_info' and 'get_speed_limits_mode'.\n\
  537|      0|                                     After investigating, suggest specific fixes (like re-announcing, toggling sequential download, or changing limits).",
  538|      0|                                    hash, instance, instance, hash, instance, hash, instance, hash
  539|      0|                                )
  540|      0|                            }
  541|      0|                        }
  542|      0|                    ]
  543|      0|                }))
  544|       |            }
  545|      1|            "analyze_disk_space" => Ok(json!({
                                                  ^0 ^0
  546|      0|                "description": format!("Analyze disk space on instance {}", instance),
  547|      0|                "messages": [
  548|      0|                    {
  549|      0|                        "role": "user",
  550|      0|                        "content": {
  551|      0|                            "type": "text",
  552|      0|                            "text": format!(
  553|      0|                                "I want to check if I have enough disk space for my downloads on instance '{}'. \
  554|      0|                                 Please check the current free space on disk and compare it with the total size of active/downloading torrents. \
  555|      0|                                 You can get global transfer info and list all torrents to calculate the required space.",
  556|      0|                                instance
  557|      0|                            )
  558|      0|                        }
  559|      0|                    }
  560|      0|                ]
  561|      0|            })),
  562|      1|            "optimize_speed" => Ok(json!({
                                              ^0 ^0
  563|      0|                "description": format!("Optimize download speeds on instance {}", instance),
  564|      0|                "messages": [
  565|      0|                    {
  566|      0|                        "role": "user",
  567|      0|                        "content": {
  568|      0|                            "type": "text",
  569|      0|                            "text": format!(
  570|      0|                                "My downloads are slow on instance '{}'. Please analyze my current global limits, \
  571|      0|                                 alternative speed limits mode, and connection status (firewalled state, DHT nodes) to suggest optimizations.",
  572|      0|                                instance
  573|      0|                            )
  574|      0|                        }
  575|      0|                    }
  576|      0|                ]
  577|      0|            })),
  578|      1|            "troubleshoot_connection" => Ok(json!({
                                                       ^0 ^0
  579|      0|                "description": format!("Troubleshoot connection issues on instance {}", instance),
  580|      0|                "messages": [
  581|      0|                    {
  582|      0|                        "role": "user",
  583|      0|                        "content": {
  584|      0|                            "type": "text",
  585|      0|                            "text": format!(
  586|      0|                                "I think I have connection issues on instance '{}'. Please check my DHT node count and connection status, \
  587|      0|                                 and verify if alternative speed limits are accidentally enabled.",
  588|      0|                                instance
  589|      0|                            )
  590|      0|                        }
  591|      0|                    }
  592|      0|                ]
  593|      0|            })),
  594|      1|            "rules-of-engagement" => Ok(json!({
  595|      1|                "description": "Rules of Engagement for qBittorrent MCP",
  596|      1|                "messages": [
  597|      1|                    {
  598|      1|                        "role": "user",
  599|      1|                        "content": {
  600|      1|                            "type": "text",
  601|      1|                            "text": "Please provide the Rules of Engagement for this MCP server."
  602|      1|                        }
  603|      1|                    },
  604|      1|                    {
  605|      1|                        "role": "assistant",
  606|      1|                        "content": {
  607|      1|                            "type": "text",
  608|      1|                            "text": "As an AI agent interacting with the qBittorrent MCP server, you must adhere to the following Rules of Engagement:\n\n\
  609|      1|                                     1. **State Verification**: Always verify the current state of a torrent (via `list_torrents` or resources) before performing actions like pause, resume, or delete.\n\
  610|      1|                                     2. **Destructive Actions**: Clearly inform the user and obtain confirmation before calling `delete_torrent` or `shutdown_app`. For these \"destructive\" actions, use the `destructiveHint` annotation or require a separate confirmation step.\n\
  611|      1|                                     3. **Search Etiquette**: Search is asynchronous. Use `get_search_results` for polling and always call `stop_search` once finished to save resources.\n\
  612|      1|                                     4. **Error Handling**: Treat errors as information for self-correction. Return helpful hints and use `isError: true` to prevent hallucination.\n\
  613|      1|                                     5. **Idempotency**: Avoid redundant commands (e.g., do not pause an already paused torrent).\n\
  614|      1|                                     6. **Semantic Feedback**: Translate technical tool results into meaningful context for the user.\n\
  615|      1|                                     7. **Security**: Never expose sensitive credentials or session cookies in logs or to the user."
  616|      1|                        }
  617|      1|                    }
  618|      1|                ]
  619|      1|            })),
  620|      0|            _ => anyhow::bail!("Prompt not found: {}", name),
  621|       |        }
  622|      1|    }
  623|       |
  624|      1|    fn get_tool_definitions(&self) -> Vec<Value> {
  625|      1|        let state = self.state.lock().unwrap();
  626|      1|        if state.lazy_mode && !state.tools_loaded {
                                            ^0
  627|      0|            return vec![
  628|      0|                json!({
  629|      0|                    "name": "list_torrents",
  630|      0|                    "description": "List all torrents with optional filtering and sorting",
  631|      0|                    "inputSchema": {
  632|      0|                        "type": "object",
  633|      0|                        "properties": {
  634|      0|                            "instance": { "type": "string", "description": "Optional: Name of the qBittorrent instance" },
  635|      0|                            "filter": { "type": "string", "description": "Filter by status (all, downloading, completed, paused, active, inactive, resumed, stalled, stalled_uploading, stalled_downloading, errored)" },
  636|      0|                            "category": { "type": "string", "description": "Filter by category" },
  637|      0|                            "tag": { "type": "string", "description": "Filter by tag" },
  638|      0|                            "sort": { "type": "string", "description": "Sort by column name" },
  639|      0|                            "reverse": { "type": "boolean", "description": "True to reverse sort order" },
  640|      0|                            "limit": { "type": "integer", "description": "Maximum number of torrents to return" },
  641|      0|                            "offset": { "type": "integer", "description": "Number of torrents to skip" }
  642|       |                        },
  643|      0|                        "required": []
  644|       |                    }
  645|       |                }),
  646|      0|                json!({
  647|      0|                    "name": "show_all_tools",
  648|      0|                    "description": "Enable all available tools",
  649|      0|                    "inputSchema": {
  650|      0|                        "type": "object",
  651|      0|                        "properties": {},
  652|      0|                        "required": []
  653|       |                    }
  654|       |                }),
  655|       |            ];
  656|      1|        }
  657|       |
  658|      1|        let mut tools = Vec::new();
  659|      1|        tools.extend(self.get_torrent_tools());
  660|      1|        tools.extend(self.get_search_tools());
  661|      1|        tools.extend(self.get_transfer_tools());
  662|      1|        tools.extend(self.get_rss_tools());
  663|      1|        tools.extend(self.get_app_tools());
  664|       |
  665|       |        // Inject instance parameter into all tools
  666|      1|        tools
  667|      1|            .into_iter()
  668|     55|            .map(|mut t| {
                           ^1
  669|     55|                let props = t
  670|     55|                    .get_mut("inputSchema")
  671|     55|                    .and_then(|s| s.get_mut("properties"));
  672|       |
  673|     55|                if let Some(obj) = props.and_then(|p| p.as_object_mut()) {
  674|     55|                    obj.insert(
  675|     55|                        "instance".to_string(),
  676|     55|                        json!({ "type": "string", "description": "Optional: Name of the qBittorrent instance to target" }),
  677|     55|                    );
  678|     55|                }
                              ^0
  679|     55|                t
  680|     55|            })
  681|      1|            .collect()
  682|      1|    }
  683|       |
  684|      1|    fn get_torrent_tools(&self) -> Vec<Value> {
  685|      1|        vec![
  686|      1|            json!({
  687|      1|                "name": "list_torrents",
  688|      1|                "description": "List all torrents with optional filtering and sorting",
  689|      1|                "inputSchema": {
  690|      1|                    "type": "object",
  691|      1|                    "properties": {
  692|      1|                        "filter": { "type": "string", "description": "Filter by status (all, downloading, completed, paused, active, inactive, resumed, stalled, stalled_uploading, stalled_downloading, errored)" },
  693|      1|                        "category": { "type": "string", "description": "Filter by category" },
  694|      1|                        "tag": { "type": "string", "description": "Filter by tag" },
  695|      1|                        "sort": { "type": "string", "description": "Sort by column name (e.g., name, size, progress, added_on, dlspeed, upspeed, ratio, eta, state, category, tags)" },
  696|      1|                        "reverse": { "type": "boolean", "description": "True to reverse sort order" },
  697|      1|                        "limit": { "type": "integer", "description": "Maximum number of torrents to return" },
  698|      1|                        "offset": { "type": "integer", "description": "Number of torrents to skip" }
  699|       |                    },
  700|      1|                    "required": []
  701|       |                }
  702|       |            }),
  703|      1|            json!({
  704|      1|                "name": "add_torrent",
  705|      1|                "description": "Add a new torrent",
  706|      1|                "inputSchema": {
  707|      1|                    "type": "object",
  708|      1|                    "properties": {
  709|      1|                        "url": { "type": "string", "description": "Magnet URI or HTTP URL" },
  710|      1|                        "save_path": { "type": "string", "description": "Optional save path" },
  711|      1|                        "category": { "type": "string", "description": "Optional category" }
  712|       |                    },
  713|      1|                    "required": ["url"]
  714|       |                }
  715|       |            }),
  716|      1|            json!({
  717|      1|                "name": "pause_torrent",
  718|      1|                "description": "Pause a torrent. ALWAYS verify torrent exists and its current state via list_torrents before calling this.",
  719|      1|                "inputSchema": {
  720|      1|                    "type": "object",
  721|      1|                    "properties": {
  722|      1|                        "hash": { "type": "string", "description": "Torrent hash (pipe-separated for multiple)" }
  723|       |                    },
  724|      1|                    "required": ["hash"]
  725|       |                }
  726|       |            }),
  727|      1|            json!({
  728|      1|                "name": "resume_torrent",
  729|      1|                "description": "Resume a torrent. ALWAYS verify torrent exists and its current state via list_torrents before calling this.",
  730|      1|                "inputSchema": {
  731|      1|                    "type": "object",
  732|      1|                    "properties": {
  733|      1|                        "hash": { "type": "string", "description": "Torrent hash (pipe-separated for multiple)" }
  734|       |                    },
  735|      1|                    "required": ["hash"]
  736|       |                }
  737|       |            }),
  738|      1|            json!({
  739|      1|                "name": "delete_torrent",
  740|      1|                "description": "Delete a torrent. DESTRUCTIVE: Inform the user and confirm before calling, especially if delete_files is true.",
  741|      1|                "inputSchema": {
  742|      1|                    "type": "object",
  743|      1|                    "properties": {
  744|      1|                        "hash": { "type": "string", "description": "Torrent hash (pipe-separated for multiple)" },
  745|      1|                        "delete_files": { "type": "boolean", "description": "Also delete files from disk" }
  746|       |                    },
  747|      1|                    "required": ["hash", "delete_files"]
  748|       |                }
  749|       |            }),
  750|      1|            json!({
  751|      1|                "name": "reannounce_torrent",
  752|      1|                "description": "Reannounce a torrent",
  753|      1|                "inputSchema": {
  754|      1|                    "type": "object",
  755|      1|                    "properties": {
  756|      1|                        "hash": { "type": "string", "description": "Torrent hash (pipe-separated for multiple)" }
  757|       |                    },
  758|      1|                    "required": ["hash"]
  759|       |                }
  760|       |            }),
  761|      1|            json!({
  762|      1|                "name": "recheck_torrent",
  763|      1|                "description": "Recheck a torrent",
  764|      1|                "inputSchema": {
  765|      1|                    "type": "object",
  766|      1|                    "properties": {
  767|      1|                        "hash": { "type": "string", "description": "Torrent hash (pipe-separated for multiple)" }
  768|       |                    },
  769|      1|                    "required": ["hash"]
  770|       |                }
  771|       |            }),
  772|      1|            json!({
  773|      1|                "name": "get_torrent_files",
  774|      1|                "description": "Get file list of a torrent",
  775|      1|                "inputSchema": {
  776|      1|                    "type": "object",
  777|      1|                    "properties": {
  778|      1|                        "hash": { "type": "string", "description": "Torrent hash" }
  779|       |                    },
  780|      1|                    "required": ["hash"]
  781|       |                }
  782|       |            }),
  783|      1|            json!({
  784|      1|                "name": "get_torrent_properties",
  785|      1|                "description": "Get properties of a torrent",
  786|      1|                "inputSchema": {
  787|      1|                    "type": "object",
  788|      1|                    "properties": {
  789|      1|                        "hash": { "type": "string", "description": "Torrent hash" }
  790|       |                    },
  791|      1|                    "required": ["hash"]
  792|       |                }
  793|       |            }),
  794|      1|            json!({
  795|      1|                "name": "create_category",
  796|      1|                "description": "Create a new category",
  797|      1|                "inputSchema": {
  798|      1|                    "type": "object",
  799|      1|                    "properties": {
  800|      1|                        "name": { "type": "string", "description": "Category name" },
  801|      1|                        "save_path": { "type": "string", "description": "Save path for category" }
  802|       |                    },
  803|      1|                    "required": ["name", "save_path"]
  804|       |                }
  805|       |            }),
  806|      1|            json!({
  807|      1|                "name": "set_torrent_category",
  808|      1|                "description": "Set category for torrents",
  809|      1|                "inputSchema": {
  810|      1|                    "type": "object",
  811|      1|                    "properties": {
  812|      1|                        "hashes": { "type": "string", "description": "Torrent hashes (pipe-separated)" },
  813|      1|                        "category": { "type": "string", "description": "Category name" }
  814|       |                    },
  815|      1|                    "required": ["hashes", "category"]
  816|       |                }
  817|       |            }),
  818|      1|            json!({
  819|      1|                "name": "get_categories",
  820|      1|                "description": "Get all categories",
  821|      1|                "inputSchema": {
  822|      1|                    "type": "object",
  823|      1|                    "properties": {},
  824|      1|                    "required": []
  825|       |                }
  826|       |            }),
  827|      1|            json!({
  828|      1|                "name": "add_torrent_tags",
  829|      1|                "description": "Add tags to torrents",
  830|      1|                "inputSchema": {
  831|      1|                    "type": "object",
  832|      1|                    "properties": {
  833|      1|                        "hashes": { "type": "string", "description": "Torrent hashes (pipe-separated)" },
  834|      1|                        "tags": { "type": "string", "description": "Comma-separated tags" }
  835|       |                    },
  836|      1|                    "required": ["hashes", "tags"]
  837|       |                }
  838|       |            }),
  839|      1|            json!({
  840|      1|                "name": "wait_for_torrent_status",
  841|      1|                "description": "Poll a torrent until it reaches a desired state or timeout",
  842|      1|                "inputSchema": {
  843|      1|                    "type": "object",
  844|      1|                    "properties": {
  845|      1|                        "hash": { "type": "string", "description": "Torrent hash" },
  846|      1|                        "target_status": { "type": "string", "description": "Status to wait for (e.g., uploading, stalledUP)" },
  847|      1|                        "timeout_seconds": { "type": "integer", "description": "Max wait time (default 60, max 300)" }
  848|       |                    },
  849|      1|                    "required": ["hash", "target_status"]
  850|       |                }
  851|       |            }),
  852|      1|            json!({
  853|      1|                "name": "cleanup_completed",
  854|      1|                "description": "Bulk remove completed torrents based on ratio or age. DESTRUCTIVE: Inform the user and confirm before calling.",
  855|      1|                "inputSchema": {
  856|      1|                    "type": "object",
  857|      1|                    "properties": {
  858|      1|                        "min_ratio": { "type": "number", "description": "Minimum ratio to trigger removal" },
  859|      1|                        "max_age_days": { "type": "integer", "description": "Maximum age in days since completion to trigger removal" },
  860|      1|                        "delete_files": { "type": "boolean", "description": "Also delete downloaded files from disk" }
  861|       |                    },
  862|      1|                    "required": ["delete_files"]
  863|       |                }
  864|       |            }),
  865|      1|            json!({
  866|      1|                "name": "mass_rename",
  867|      1|                "description": "Rename files in a torrent using a regex pattern",
  868|      1|                "inputSchema": {
  869|      1|                    "type": "object",
  870|      1|                    "properties": {
  871|      1|                        "hash": { "type": "string", "description": "Torrent hash" },
  872|      1|                        "pattern": { "type": "string", "description": "Regex pattern to match" },
  873|      1|                        "replacement": { "type": "string", "description": "Replacement string (supports $1, $2, etc.)" }
  874|       |                    },
  875|      1|                    "required": ["hash", "pattern", "replacement"]
  876|       |                }
  877|       |            }),
  878|      1|            json!({
  879|      1|                "name": "find_duplicates",
  880|      1|                "description": "Find duplicate torrents by name",
  881|      1|                "inputSchema": {
  882|      1|                    "type": "object",
  883|      1|                    "properties": {},
  884|      1|                    "required": []
  885|       |                }
  886|       |            }),
  887|      1|            json!({
  888|      1|                "name": "set_torrent_share_limits",
  889|      1|                "description": "Set share limits for specific torrents",
  890|      1|                "inputSchema": {
  891|      1|                    "type": "object",
  892|      1|                    "properties": {
  893|      1|                        "hashes": { "type": "string", "description": "Torrent hashes (pipe-separated)" },
  894|      1|                        "ratio_limit": { "type": "number", "description": "Ratio limit (-2 for global, -1 for unlimited)" },
  895|      1|                        "seeding_time_limit": { "type": "integer", "description": "Seeding time limit in minutes (-2 for global, -1 for unlimited)" },
  896|      1|                        "inactive_seeding_time_limit": { "type": "integer", "description": "Inactive seeding time limit in minutes (-2 for global, -1 for unlimited)" }
  897|       |                    },
  898|      1|                    "required": ["hashes", "ratio_limit", "seeding_time_limit"]
  899|       |                }
  900|       |            }),
  901|      1|            json!({
  902|      1|                "name": "set_torrent_speed_limits",
  903|      1|                "description": "Set download and/or upload limits for specific torrents",
  904|      1|                "inputSchema": {
  905|      1|                    "type": "object",
  906|      1|                    "properties": {
  907|      1|                        "hashes": { "type": "string", "description": "Torrent hashes (pipe-separated)" },
  908|      1|                        "dl_limit": { "type": "integer", "description": "Download limit in bytes per second (0 for unlimited)" },
  909|      1|                        "up_limit": { "type": "integer", "description": "Upload limit in bytes per second (0 for unlimited)" }
  910|       |                    },
  911|      1|                    "required": ["hashes"]
  912|       |                }
  913|       |            }),
  914|      1|            json!({
  915|      1|                "name": "toggle_sequential_download",
  916|      1|                "description": "Toggle sequential download for torrents",
  917|      1|                "inputSchema": {
  918|      1|                    "type": "object",
  919|      1|                    "properties": {
  920|      1|                        "hashes": { "type": "string", "description": "Torrent hashes (pipe-separated)" }
  921|       |                    },
  922|      1|                    "required": ["hashes"]
  923|       |                }
  924|       |            }),
  925|      1|            json!({
  926|      1|                "name": "toggle_first_last_piece_priority",
  927|      1|                "description": "Toggle first/last piece priority for torrents",
  928|      1|                "inputSchema": {
  929|      1|                    "type": "object",
  930|      1|                    "properties": {
  931|      1|                        "hashes": { "type": "string", "description": "Torrent hashes (pipe-separated)" }
  932|       |                    },
  933|      1|                    "required": ["hashes"]
  934|       |                }
  935|       |            }),
  936|      1|            json!({
  937|      1|                "name": "set_force_start",
  938|      1|                "description": "Set force start for torrents",
  939|      1|                "inputSchema": {
  940|      1|                    "type": "object",
  941|      1|                    "properties": {
  942|      1|                        "hashes": { "type": "string", "description": "Torrent hashes (pipe-separated)" },
  943|      1|                        "value": { "type": "boolean", "description": "True to force start, False otherwise" }
  944|       |                    },
  945|      1|                    "required": ["hashes", "value"]
  946|       |                }
  947|       |            }),
  948|      1|            json!({
  949|      1|                "name": "set_super_seeding",
  950|      1|                "description": "Set super seeding for torrents",
  951|      1|                "inputSchema": {
  952|      1|                    "type": "object",
  953|      1|                    "properties": {
  954|      1|                        "hashes": { "type": "string", "description": "Torrent hashes (pipe-separated)" },
  955|      1|                        "value": { "type": "boolean", "description": "True to enable super seeding, False otherwise" }
  956|       |                    },
  957|      1|                    "required": ["hashes", "value"]
  958|       |                }
  959|       |            }),
  960|      1|            json!({
  961|      1|                "name": "add_trackers",
  962|      1|                "description": "Add trackers to torrents",
  963|      1|                "inputSchema": {
  964|      1|                    "type": "object",
  965|      1|                    "properties": {
  966|      1|                        "hashes": { "type": "string", "description": "Torrent hashes (pipe-separated)" },
  967|      1|                        "urls": { "type": "string", "description": "URLs of the trackers (newline-separated)" }
  968|       |                    },
  969|      1|                    "required": ["hashes", "urls"]
  970|       |                }
  971|       |            }),
  972|      1|            json!({
  973|      1|                "name": "edit_tracker",
  974|      1|                "description": "Edit a tracker URL for a torrent",
  975|      1|                "inputSchema": {
  976|      1|                    "type": "object",
  977|      1|                    "properties": {
  978|      1|                        "hash": { "type": "string", "description": "Torrent hash" },
  979|      1|                        "orig_url": { "type": "string", "description": "Original tracker URL" },
  980|      1|                        "new_url": { "type": "string", "description": "New tracker URL" }
  981|       |                    },
  982|      1|                    "required": ["hash", "orig_url", "new_url"]
  983|       |                }
  984|       |            }),
  985|      1|            json!({
  986|      1|                "name": "remove_trackers",
  987|      1|                "description": "Remove trackers from torrents",
  988|      1|                "inputSchema": {
  989|      1|                    "type": "object",
  990|      1|                    "properties": {
  991|      1|                        "hashes": { "type": "string", "description": "Torrent hashes (pipe-separated)" },
  992|      1|                        "urls": { "type": "string", "description": "URLs of the trackers to remove (newline-separated)" }
  993|       |                    },
  994|      1|                    "required": ["hashes", "urls"]
  995|       |                }
  996|       |            }),
  997|      1|            json!({
  998|      1|                "name": "rename_folder",
  999|      1|                "description": "Rename a folder in a torrent",
 1000|      1|                "inputSchema": {
 1001|      1|                    "type": "object",
 1002|      1|                    "properties": {
 1003|      1|                        "hash": { "type": "string", "description": "Torrent hash" },
 1004|      1|                        "old_path": { "type": "string", "description": "Current folder path" },
 1005|      1|                        "new_path": { "type": "string", "description": "New folder path" }
 1006|       |                    },
 1007|      1|                    "required": ["hash", "old_path", "new_path"]
 1008|       |                }
 1009|       |            }),
 1010|      1|            json!({
 1011|      1|                "name": "set_file_priority",
 1012|      1|                "description": "Set priority for files in a torrent",
 1013|      1|                "inputSchema": {
 1014|      1|                    "type": "object",
 1015|      1|                    "properties": {
 1016|      1|                        "hash": { "type": "string", "description": "Torrent hash" },
 1017|      1|                        "id": { "type": "string", "description": "File IDs (pipe-separated)" },
 1018|      1|                        "priority": { "type": "integer", "description": "Priority (0: Do not download, 1: Normal, 6: High, 7: Maximal)" }
 1019|       |                    },
 1020|      1|                    "required": ["hash", "id", "priority"]
 1021|       |                }
 1022|       |            }),
 1023|      1|            json!({
 1024|      1|                "name": "remove_categories",
 1025|      1|                "description": "Remove one or more categories",
 1026|      1|                "inputSchema": {
 1027|      1|                    "type": "object",
 1028|      1|                    "properties": {
 1029|      1|                        "categories": { "type": "string", "description": "Category names (newline-separated)" }
 1030|       |                    },
 1031|      1|                    "required": ["categories"]
 1032|       |                }
 1033|       |            }),
 1034|      1|            json!({
 1035|      1|                "name": "remove_tags",
 1036|      1|                "description": "Remove tags from torrents",
 1037|      1|                "inputSchema": {
 1038|      1|                    "type": "object",
 1039|      1|                    "properties": {
 1040|      1|                        "hashes": { "type": "string", "description": "Torrent hashes (pipe-separated)" },
 1041|      1|                        "tags": { "type": "string", "description": "Tags to remove (comma-separated)" }
 1042|       |                    },
 1043|      1|                    "required": ["hashes", "tags"]
 1044|       |                }
 1045|       |            }),
 1046|      1|            json!({
 1047|      1|                "name": "create_tags",
 1048|      1|                "description": "Create one or more tags",
 1049|      1|                "inputSchema": {
 1050|      1|                    "type": "object",
 1051|      1|                    "properties": {
 1052|      1|                        "tags": { "type": "string", "description": "Tags to create (comma-separated)" }
 1053|       |                    },
 1054|      1|                    "required": ["tags"]
 1055|       |                }
 1056|       |            }),
 1057|      1|            json!({
 1058|      1|                "name": "delete_tags",
 1059|      1|                "description": "Delete one or more tags",
 1060|      1|                "inputSchema": {
 1061|      1|                    "type": "object",
 1062|      1|                    "properties": {
 1063|      1|                        "tags": { "type": "string", "description": "Tags to delete (comma-separated)" }
 1064|       |                    },
 1065|      1|                    "required": ["tags"]
 1066|       |                }
 1067|       |            }),
 1068|       |        ]
 1069|      1|    }
 1070|       |
 1071|      1|    fn get_search_tools(&self) -> Vec<Value> {
 1072|      1|        vec![
 1073|      1|            json!({
 1074|      1|                "name": "search_torrents",
 1075|      1|                "description": "Search for torrents. ASYNCHRONOUS: Results might be incomplete on the first call. Use get_search_results for polling if needed.",
 1076|      1|                "inputSchema": {
 1077|      1|                    "type": "object",
 1078|      1|                    "properties": {
 1079|      1|                        "query": { "type": "string", "description": "Search query" },
 1080|      1|                        "category": { "type": "string", "description": "Optional category" }
 1081|       |                    },
 1082|      1|                    "required": ["query"]
 1083|       |                }
 1084|       |            }),
 1085|      1|            json!({
 1086|      1|                "name": "install_search_plugin",
 1087|      1|                "description": "Install a search plugin",
 1088|      1|                "inputSchema": {
 1089|      1|                    "type": "object",
 1090|      1|                    "properties": {
 1091|      1|                        "url": { "type": "string", "description": "URL to the plugin file" }
 1092|       |                    },
 1093|      1|                    "required": ["url"]
 1094|       |                }
 1095|       |            }),
 1096|      1|            json!({
 1097|      1|                "name": "uninstall_search_plugin",
 1098|      1|                "description": "Uninstall a search plugin",
 1099|      1|                "inputSchema": {
 1100|      1|                    "type": "object",
 1101|      1|                    "properties": {
 1102|      1|                        "name": { "type": "string", "description": "Name of the plugin" }
 1103|       |                    },
 1104|      1|                    "required": ["name"]
 1105|       |                }
 1106|       |            }),
 1107|      1|            json!({
 1108|      1|                "name": "enable_search_plugin",
 1109|      1|                "description": "Enable or disable a search plugin",
 1110|      1|                "inputSchema": {
 1111|      1|                    "type": "object",
 1112|      1|                    "properties": {
 1113|      1|                        "name": { "type": "string", "description": "Name of the plugin" },
 1114|      1|                        "enable": { "type": "boolean", "description": "True to enable, False to disable" }
 1115|       |                    },
 1116|      1|                    "required": ["name", "enable"]
 1117|       |                }
 1118|       |            }),
 1119|      1|            json!({
 1120|      1|                "name": "update_search_plugins",
 1121|      1|                "description": "Update all search plugins",
 1122|      1|                "inputSchema": {
 1123|      1|                    "type": "object",
 1124|      1|                    "properties": {},
 1125|      1|                    "required": []
 1126|       |                }
 1127|       |            }),
 1128|      1|            json!({
 1129|      1|                "name": "get_search_plugins",
 1130|      1|                "description": "List installed search plugins",
 1131|      1|                "inputSchema": {
 1132|      1|                    "type": "object",
 1133|      1|                    "properties": {},
 1134|      1|                    "required": []
 1135|       |                }
 1136|       |            }),
 1137|       |        ]
 1138|      1|    }
 1139|       |
 1140|      1|    fn get_transfer_tools(&self) -> Vec<Value> {
 1141|      1|        vec![
 1142|      1|            json!({
 1143|      1|                "name": "get_global_transfer_info",
 1144|      1|                "description": "Get global transfer information",
 1145|      1|                "inputSchema": {
 1146|      1|                    "type": "object",
 1147|      1|                    "properties": {},
 1148|      1|                    "required": []
 1149|       |                }
 1150|       |            }),
 1151|      1|            json!({
 1152|      1|                "name": "set_global_transfer_limits",
 1153|      1|                "description": "Set global download and/or upload limits",
 1154|      1|                "inputSchema": {
 1155|      1|                    "type": "object",
 1156|      1|                    "properties": {
 1157|      1|                        "dl_limit": { "type": "integer", "description": "Download limit in bytes per second (0 for unlimited)" },
 1158|      1|                        "up_limit": { "type": "integer", "description": "Upload limit in bytes per second (0 for unlimited)" }
 1159|       |                    },
 1160|      1|                    "required": []
 1161|       |                }
 1162|       |            }),
 1163|      1|            json!({
 1164|      1|                "name": "toggle_alternative_speed_limits",
 1165|      1|                "description": "Toggle alternative speed limits",
 1166|      1|                "inputSchema": {
 1167|      1|                    "type": "object",
 1168|      1|                    "properties": {},
 1169|      1|                    "required": []
 1170|       |                }
 1171|       |            }),
 1172|      1|            json!({
 1173|      1|                "name": "get_speed_limits_mode",
 1174|      1|                "description": "Get the current state of alternative speed limits (0 for disabled, 1 for enabled)",
 1175|      1|                "inputSchema": {
 1176|      1|                    "type": "object",
 1177|      1|                    "properties": {},
 1178|      1|                    "required": []
 1179|       |                }
 1180|       |            }),
 1181|      1|            json!({
 1182|      1|                "name": "ban_peers",
 1183|      1|                "description": "Ban a list of peers",
 1184|      1|                "inputSchema": {
 1185|      1|                    "type": "object",
 1186|      1|                    "properties": {
 1187|      1|                        "peers": { "type": "string", "description": "Peers to ban (host:port, pipe-separated)" }
 1188|       |                    },
 1189|      1|                    "required": ["peers"]
 1190|       |                }
 1191|       |            }),
 1192|       |        ]
 1193|      1|    }
 1194|       |
 1195|      1|    fn get_rss_tools(&self) -> Vec<Value> {
 1196|      1|        vec![
 1197|      1|            json!({
 1198|      1|                "name": "add_rss_feed",
 1199|      1|                "description": "Add a new RSS feed",
 1200|      1|                "inputSchema": {
 1201|      1|                    "type": "object",
 1202|      1|                    "properties": {
 1203|      1|                        "url": { "type": "string", "description": "URL of the RSS feed" },
 1204|      1|                        "path": { "type": "string", "description": "Internal path/name for the feed" }
 1205|       |                    },
 1206|      1|                    "required": ["url", "path"]
 1207|       |                }
 1208|       |            }),
 1209|      1|            json!({
 1210|      1|                "name": "get_rss_feeds",
 1211|      1|                "description": "Get all RSS feeds and their items",
 1212|      1|                "inputSchema": {
 1213|      1|                    "type": "object",
 1214|      1|                    "properties": {},
 1215|      1|                    "required": []
 1216|       |                }
 1217|       |            }),
 1218|      1|            json!({
 1219|      1|                "name": "set_rss_rule",
 1220|      1|                "description": "Create or update an RSS auto-download rule",
 1221|      1|                "inputSchema": {
 1222|      1|                    "type": "object",
 1223|      1|                    "properties": {
 1224|      1|                        "name": { "type": "string", "description": "Name of the rule" },
 1225|      1|                        "definition": { "type": "string", "description": "JSON string defining the rule" }
 1226|       |                    },
 1227|      1|                    "required": ["name", "definition"]
 1228|       |                }
 1229|       |            }),
 1230|      1|            json!({
 1231|      1|                "name": "get_rss_rules",
 1232|      1|                "description": "Get all RSS auto-download rules",
 1233|      1|                "inputSchema": {
 1234|      1|                    "type": "object",
 1235|      1|                    "properties": {},
 1236|      1|                    "required": []
 1237|       |                }
 1238|       |            }),
 1239|      1|            json!({
 1240|      1|                "name": "move_rss_item",
 1241|      1|                "description": "Move an RSS item (feed or folder)",
 1242|      1|                "inputSchema": {
 1243|      1|                    "type": "object",
 1244|      1|                    "properties": {
 1245|      1|                        "item_path": { "type": "string", "description": "Current path of the item" },
 1246|      1|                        "dest_path": { "type": "string", "description": "Destination path" }
 1247|       |                    },
 1248|      1|                    "required": ["item_path", "dest_path"]
 1249|       |                }
 1250|       |            }),
 1251|       |        ]
 1252|      1|    }
 1253|       |
 1254|      1|    fn get_app_tools(&self) -> Vec<Value> {
 1255|      1|        vec![
 1256|      1|            json!({
 1257|      1|                "name": "get_app_preferences",
 1258|      1|                "description": "Get all application preferences",
 1259|      1|                "inputSchema": {
 1260|      1|                    "type": "object",
 1261|      1|                    "properties": {},
 1262|      1|                    "required": []
 1263|       |                }
 1264|       |            }),
 1265|      1|            json!({
 1266|      1|                "name": "set_app_preferences",
 1267|      1|                "description": "Set one or more application preferences",
 1268|      1|                "inputSchema": {
 1269|      1|                    "type": "object",
 1270|      1|                    "properties": {
 1271|      1|                        "preferences": { "type": "string", "description": "JSON string of preferences to update" }
 1272|       |                    },
 1273|      1|                    "required": ["preferences"]
 1274|       |                }
 1275|       |            }),
 1276|      1|            json!({
 1277|      1|                "name": "get_main_log",
 1278|      1|                "description": "Get the main application log",
 1279|      1|                "inputSchema": {
 1280|      1|                    "type": "object",
 1281|      1|                    "properties": {
 1282|      1|                        "severity": { "type": "string", "description": "Filter by severity (all, info, warning, critical)" },
 1283|      1|                        "last_id": { "type": "integer", "description": "Exclude logs with ID less than or equal to this" }
 1284|       |                    },
 1285|      1|                    "required": []
 1286|       |                }
 1287|       |            }),
 1288|      1|            json!({
 1289|      1|                "name": "get_peer_log",
 1290|      1|                "description": "Get the peer connection log",
 1291|      1|                "inputSchema": {
 1292|      1|                    "type": "object",
 1293|      1|                    "properties": {
 1294|      1|                        "last_id": { "type": "integer", "description": "Exclude logs with ID less than or equal to this" }
 1295|       |                    },
 1296|      1|                    "required": []
 1297|       |                }
 1298|       |            }),
 1299|      1|            json!({
 1300|      1|                "name": "get_app_version",
 1301|      1|                "description": "Get application version",
 1302|      1|                "inputSchema": {
 1303|      1|                    "type": "object",
 1304|      1|                    "properties": {},
 1305|      1|                    "required": []
 1306|       |                }
 1307|       |            }),
 1308|      1|            json!({
 1309|      1|                "name": "get_build_info",
 1310|      1|                "description": "Get build information",
 1311|      1|                "inputSchema": {
 1312|      1|                    "type": "object",
 1313|      1|                    "properties": {},
 1314|      1|                    "required": []
 1315|       |                }
 1316|       |            }),
 1317|      1|            json!({
 1318|      1|                "name": "shutdown_app",
 1319|      1|                "description": "Shutdown qBittorrent. DESTRUCTIVE: Inform the user and confirm before calling as this terminates the service.",
 1320|      1|                "inputSchema": {
 1321|      1|                    "type": "object",
 1322|      1|                    "properties": {},
 1323|      1|                    "required": []
 1324|       |                }
 1325|       |            }),
 1326|       |        ]
 1327|      1|    }
 1328|       |
 1329|     57|    pub async fn call_tool(&self, name: &str, args: &Value) -> Result<Value> {
 1330|     57|        if name == "show_all_tools" {
 1331|      0|            return self.handle_show_all_tools();
 1332|     57|        }
 1333|       |
 1334|     57|        let instance = args.get("instance").and_then(|v| v.as_str());
                                                                       ^0^0
 1335|     57|        let client = self.get_client(instance)?;
                                                            ^0
 1336|       |
 1337|     57|        match name {
 1338|       |            // Torrent Management
 1339|     57|            "list_torrents" => self.handle_list_torrents(client, args).await,
                                             ^2   ^2                   ^2
 1340|     55|            "add_torrent" => self.handle_add_torrent(client, args).await,
                                           ^1   ^1                 ^1
 1341|     54|            "pause_torrent" => self.handle_pause_torrent(client, args).await,
                                             ^1   ^1                   ^1
 1342|     53|            "resume_torrent" => self.handle_resume_torrent(client, args).await,
                                              ^1   ^1                    ^1
 1343|     52|            "delete_torrent" => self.handle_delete_torrent(client, args).await,
                                              ^1   ^1                    ^1
 1344|     51|            "reannounce_torrent" => self.handle_reannounce_torrent(client, args).await,
                                                  ^1   ^1                        ^1
 1345|     50|            "recheck_torrent" => self.handle_recheck_torrent(client, args).await,
                                               ^1   ^1                     ^1
 1346|     49|            "get_torrent_files" => self.handle_get_torrent_files(client, args).await,
                                                 ^1   ^1                       ^1
 1347|     48|            "get_torrent_properties" => self.handle_get_torrent_properties(client, args).await,
                                                      ^1   ^1                            ^1
 1348|     47|            "create_category" => self.handle_create_category(client, args).await,
                                               ^1   ^1                     ^1
 1349|     46|            "set_torrent_category" => self.handle_set_torrent_category(client, args).await,
                                                    ^1   ^1                          ^1
 1350|     45|            "get_categories" => self.handle_get_categories(client).await,
                                              ^1   ^1
 1351|     44|            "add_torrent_tags" => self.handle_add_torrent_tags(client, args).await,
                                                ^1   ^1                      ^1
 1352|     43|            "wait_for_torrent_status" => self.handle_wait_for_torrent_status(client, args).await,
                                                       ^1   ^1                             ^1
 1353|     42|            "cleanup_completed" => self.handle_cleanup_completed(client, args).await,
                                                 ^1   ^1                       ^1
 1354|     41|            "mass_rename" => self.handle_mass_rename(client, args).await,
                                           ^1   ^1                 ^1
 1355|     40|            "find_duplicates" => self.handle_find_duplicates(client).await,
                                               ^1   ^1
 1356|     39|            "set_torrent_share_limits" => self.handle_set_torrent_share_limits(client, args).await,
                                                        ^1   ^1                              ^1
 1357|     38|            "set_torrent_speed_limits" => self.handle_set_torrent_speed_limits(client, args).await,
                                                        ^1   ^1                              ^1
 1358|     37|            "toggle_sequential_download" => {
 1359|      1|                self.handle_toggle_sequential_download(client, args).await
 1360|       |            }
 1361|     36|            "toggle_first_last_piece_priority" => {
 1362|      1|                self.handle_toggle_first_last_piece_priority(client, args)
 1363|      1|                    .await
 1364|       |            }
 1365|     35|            "set_force_start" => self.handle_set_force_start(client, args).await,
                                               ^1   ^1                     ^1
 1366|     34|            "set_super_seeding" => self.handle_set_super_seeding(client, args).await,
                                                 ^1   ^1                       ^1
 1367|     33|            "add_trackers" => self.handle_add_trackers(client, args).await,
                                            ^1   ^1                  ^1
 1368|     32|            "edit_tracker" => self.handle_edit_tracker(client, args).await,
                                            ^1   ^1                  ^1
 1369|     31|            "remove_trackers" => self.handle_remove_trackers(client, args).await,
                                               ^1   ^1                     ^1
 1370|     30|            "rename_folder" => self.handle_rename_folder(client, args).await,
                                             ^1   ^1                   ^1
 1371|     29|            "set_file_priority" => self.handle_set_file_priority(client, args).await,
                                                 ^1   ^1                       ^1
 1372|     28|            "remove_categories" => self.handle_remove_categories(client, args).await,
                                                 ^1   ^1                       ^1
 1373|     27|            "remove_tags" => self.handle_remove_tags(client, args).await,
                                           ^1   ^1                 ^1
 1374|     26|            "create_tags" => self.handle_create_tags(client, args).await,
                                           ^1   ^1                 ^1
 1375|     25|            "delete_tags" => self.handle_delete_tags(client, args).await,
                                           ^1   ^1                 ^1
 1376|       |
 1377|       |            // Search
 1378|     24|            "search_torrents" => self.handle_search_torrents(client, args).await,
                                               ^1   ^1                     ^1
 1379|     23|            "install_search_plugin" => self.handle_install_search_plugin(client, args).await,
                                                     ^1   ^1                           ^1
 1380|     22|            "uninstall_search_plugin" => self.handle_uninstall_search_plugin(client, args).await,
                                                       ^1   ^1                             ^1
 1381|     21|            "enable_search_plugin" => self.handle_enable_search_plugin(client, args).await,
                                                    ^1   ^1                          ^1
 1382|     20|            "update_search_plugins" => self.handle_update_search_plugins(client).await,
                                                     ^1   ^1
 1383|     19|            "get_search_plugins" => self.handle_get_search_plugins(client).await,
                                                  ^1   ^1
 1384|       |
 1385|       |            // RSS
 1386|     18|            "add_rss_feed" => self.handle_add_rss_feed(client, args).await,
                                            ^1   ^1                  ^1
 1387|     17|            "get_rss_feeds" => self.handle_get_rss_feeds(client).await,
                                             ^1   ^1
 1388|     16|            "set_rss_rule" => self.handle_set_rss_rule(client, args).await,
                                            ^1   ^1                  ^1
 1389|     15|            "get_rss_rules" => self.handle_get_rss_rules(client).await,
                                             ^1   ^1
 1390|     14|            "move_rss_item" => self.handle_move_rss_item(client, args).await,
                                             ^1   ^1                   ^1
 1391|       |
 1392|       |            // Transfer / App
 1393|     13|            "get_global_transfer_info" => self.handle_get_global_transfer_info(client).await,
                                                        ^1   ^1
 1394|     12|            "set_global_transfer_limits" => {
 1395|      1|                self.handle_set_global_transfer_limits(client, args).await
 1396|       |            }
 1397|     11|            "toggle_alternative_speed_limits" => {
 1398|      1|                self.handle_toggle_alternative_speed_limits(client).await
 1399|       |            }
 1400|     10|            "get_speed_limits_mode" => self.handle_get_speed_limits_mode(client).await,
                                                     ^1   ^1
 1401|      9|            "ban_peers" => self.handle_ban_peers(client, args).await,
                                         ^1   ^1               ^1
 1402|      8|            "get_app_preferences" => self.handle_get_app_preferences(client).await,
                                                   ^1   ^1
 1403|      7|            "set_app_preferences" => self.handle_set_app_preferences(client, args).await,
                                                   ^1   ^1                         ^1
 1404|      6|            "get_main_log" => self.handle_get_main_log(client, args).await,
                                            ^1   ^1                  ^1
 1405|      5|            "get_peer_log" => self.handle_get_peer_log(client, args).await,
                                            ^1   ^1                  ^1
 1406|      4|            "get_app_version" => self.handle_get_app_version(client).await,
                                               ^1   ^1
 1407|      3|            "get_build_info" => self.handle_get_build_info(client).await,
                                              ^1   ^1
 1408|      2|            "shutdown_app" => self.handle_shutdown_app(client).await,
                                            ^1   ^1
 1409|       |
 1410|      1|            _ => anyhow::bail!("Unknown tool: {}", name),
 1411|       |        }
 1412|     57|    }
 1413|       |
 1414|      0|    fn handle_show_all_tools(&self) -> Result<Value> {
 1415|      0|        let mut state = self.state.lock().unwrap();
 1416|      0|        state.lazy_mode = false;
 1417|      0|        state.tools_loaded = true;
 1418|      0|        state.should_notify = true;
 1419|      0|        Ok(
 1420|      0|            json!({ "content": [{ "type": "text", "text": "All tools enabled. Please refresh your tool list." }] }),
 1421|      0|        )
 1422|      0|    }
 1423|       |
 1424|      2|    async fn handle_list_torrents(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1425|      2|        let filter = args.get("filter").and_then(|v| v.as_str());
                                                                   ^0^0
 1426|      2|        let category = args.get("category").and_then(|v| v.as_str());
                                                                       ^0^0
 1427|      2|        let tag = args.get("tag").and_then(|v| v.as_str());
                                                             ^0^0
 1428|      2|        let sort = args.get("sort").and_then(|v| v.as_str());
                                                               ^0^0
 1429|      2|        let reverse = args.get("reverse").and_then(|v| v.as_bool());
                                                                     ^0^0
 1430|      2|        let limit = args.get("limit").and_then(|v| v.as_i64());
                                                                 ^0^0
 1431|      2|        let offset = args.get("offset").and_then(|v| v.as_i64());
                                                                   ^0^0
 1432|       |
 1433|      2|        let torrents = client
 1434|      2|            .get_torrent_list(filter, category, tag, sort, reverse, limit, offset)
 1435|      2|            .await?;
                                ^0
 1436|      2|        let text = serde_json::to_string_pretty(&torrents)?;
                                                                        ^0
 1437|      2|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 1438|      2|    }
 1439|       |
 1440|      1|    async fn handle_search_torrents(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1441|      1|        let query = args
 1442|      1|            .get("query")
 1443|      1|            .and_then(|v| v.as_str())
 1444|      1|            .ok_or(anyhow::anyhow!("Missing query"))?;
                                                                  ^0
 1445|      1|        let category = args.get("category").and_then(|v| v.as_str());
                                                                       ^0^0
 1446|       |
 1447|      1|        let id = client.start_search(query, category).await?;
                                                                         ^0
 1448|       |
 1449|      1|        let mut final_results = Vec::new();
 1450|      1|        for _ in 0..5 {
 1451|      5|            sleep(Duration::from_secs(1)).await;
 1452|      5|            let resp = client.get_search_results(id, None, None).await;
 1453|      5|            if let Ok(r) = resp {
 1454|      5|                if r.status == "Stopped" {
 1455|      0|                    final_results = r.results;
 1456|      0|                    break;
 1457|      5|                }
 1458|      5|                final_results = r.results;
 1459|      0|            }
 1460|       |        }
 1461|      1|        let _ = client.stop_search(id).await;
 1462|      1|        let _ = client.delete_search(id).await;
 1463|      1|        let text = serde_json::to_string_pretty(&final_results)?;
                                                                             ^0
 1464|      1|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 1465|      1|    }
 1466|       |
 1467|      1|    async fn handle_add_torrent(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1468|      1|        let url = args
 1469|      1|            .get("url")
 1470|      1|            .and_then(|v| v.as_str())
 1471|      1|            .ok_or(anyhow::anyhow!("Missing url"))?;
                                                                ^0
 1472|      1|        let save_path = args.get("save_path").and_then(|v| v.as_str());
                                                                         ^0^0
 1473|      1|        let category = args.get("category").and_then(|v| v.as_str());
                                                                       ^0^0
 1474|      1|        client.add_torrent(url, save_path, category).await?;
                                                                        ^0
 1475|      1|        Ok(json!({ "content": [{ "type": "text", "text": "Torrent added successfully" }] }))
 1476|      1|    }
 1477|       |
 1478|      1|    async fn handle_pause_torrent(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1479|      1|        let hash = args
 1480|      1|            .get("hash")
 1481|      1|            .and_then(|v| v.as_str())
 1482|      1|            .ok_or(anyhow::anyhow!("Missing hash"))?;
                                                                 ^0
 1483|      1|        client.pause_torrents(hash).await?;
                                                       ^0
 1484|      1|        Ok(json!({ "content": [{ "type": "text", "text": "Torrent paused successfully" }] }))
 1485|      1|    }
 1486|       |
 1487|      1|    async fn handle_resume_torrent(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1488|      1|        let hash = args
 1489|      1|            .get("hash")
 1490|      1|            .and_then(|v| v.as_str())
 1491|      1|            .ok_or(anyhow::anyhow!("Missing hash"))?;
                                                                 ^0
 1492|      1|        client.resume_torrents(hash).await?;
                                                        ^0
 1493|      1|        Ok(json!({ "content": [{ "type": "text", "text": "Torrent resumed successfully" }] }))
 1494|      1|    }
 1495|       |
 1496|      1|    async fn handle_delete_torrent(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1497|      1|        let hash = args
 1498|      1|            .get("hash")
 1499|      1|            .and_then(|v| v.as_str())
 1500|      1|            .ok_or(anyhow::anyhow!("Missing hash"))?;
                                                                 ^0
 1501|      1|        let delete_files = args
 1502|      1|            .get("delete_files")
 1503|      1|            .and_then(|v| v.as_bool())
 1504|      1|            .unwrap_or(false);
 1505|      1|        client.delete_torrents(hash, delete_files).await?;
                                                                      ^0
 1506|      1|        Ok(json!({ "content": [{ "type": "text", "text": "Torrent deleted successfully" }] }))
 1507|      1|    }
 1508|       |
 1509|      1|    async fn handle_reannounce_torrent(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1510|      1|        let hash = args
 1511|      1|            .get("hash")
 1512|      1|            .and_then(|v| v.as_str())
 1513|      1|            .ok_or(anyhow::anyhow!("Missing hash"))?;
                                                                 ^0
 1514|      1|        client.reannounce_torrents(hash).await?;
                                                            ^0
 1515|      1|        Ok(json!({ "content": [{ "type": "text", "text": "Torrent reannounced successfully" }] }))
 1516|      1|    }
 1517|       |
 1518|      1|    async fn handle_recheck_torrent(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1519|      1|        let hash = args
 1520|      1|            .get("hash")
 1521|      1|            .and_then(|v| v.as_str())
 1522|      1|            .ok_or(anyhow::anyhow!("Missing hash"))?;
                                                                 ^0
 1523|      1|        client.recheck_torrents(hash).await?;
                                                         ^0
 1524|      1|        Ok(
 1525|      1|            json!({ "content": [{ "type": "text", "text": "Torrent recheck started successfully" }] }),
 1526|      1|        )
 1527|      1|    }
 1528|       |
 1529|      1|    async fn handle_get_torrent_files(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1530|      1|        let hash = args
 1531|      1|            .get("hash")
 1532|      1|            .and_then(|v| v.as_str())
 1533|      1|            .ok_or(anyhow::anyhow!("Missing hash"))?;
                                                                 ^0
 1534|      1|        let files = client.get_torrent_files(hash).await?;
                          ^0
 1535|      0|        let text = serde_json::to_string_pretty(&files)?;
 1536|      0|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 1537|      1|    }
 1538|       |
 1539|      1|    async fn handle_get_torrent_properties(
 1540|      1|        &self,
 1541|      1|        client: &QBitClient,
 1542|      1|        args: &Value,
 1543|      1|    ) -> Result<Value> {
 1544|      1|        let hash = args
 1545|      1|            .get("hash")
 1546|      1|            .and_then(|v| v.as_str())
 1547|      1|            .ok_or(anyhow::anyhow!("Missing hash"))?;
                                                                 ^0
 1548|      1|        let props = client.get_torrent_properties(hash).await?;
                          ^0
 1549|      0|        let text = serde_json::to_string_pretty(&props)?;
 1550|      0|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 1551|      1|    }
 1552|       |
 1553|      1|    async fn handle_get_global_transfer_info(&self, client: &QBitClient) -> Result<Value> {
 1554|      1|        let info = client.get_global_transfer_info().await?;
                                                                        ^0
 1555|      1|        let text = serde_json::to_string_pretty(&info)?;
                                                                    ^0
 1556|      1|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 1557|      1|    }
 1558|       |
 1559|      1|    async fn handle_set_global_transfer_limits(
 1560|      1|        &self,
 1561|      1|        client: &QBitClient,
 1562|      1|        args: &Value,
 1563|      1|    ) -> Result<Value> {
 1564|      1|        if let Some(limit) = args.get("dl_limit").and_then(|v| v.as_i64()) {
                                  ^0                                         ^0^0
 1565|      0|            client.set_download_limit(limit).await?;
 1566|      1|        }
 1567|      1|        if let Some(limit) = args.get("up_limit").and_then(|v| v.as_i64()) {
                                  ^0                                         ^0^0
 1568|      0|            client.set_upload_limit(limit).await?;
 1569|      1|        }
 1570|      1|        Ok(
 1571|      1|            json!({ "content": [{ "type": "text", "text": "Transfer limits updated successfully" }] }),
 1572|      1|        )
 1573|      1|    }
 1574|       |
 1575|      1|    async fn handle_toggle_alternative_speed_limits(&self, client: &QBitClient) -> Result<Value> {
 1576|      1|        client.toggle_alternative_speed_limits().await?;
                                                                    ^0
 1577|      1|        Ok(json!({ "content": [{ "type": "text", "text": "Alternative speed limits toggled" }] }))
 1578|      1|    }
 1579|       |
 1580|      1|    async fn handle_get_speed_limits_mode(&self, client: &QBitClient) -> Result<Value> {
 1581|      1|        let mode = client.get_speed_limits_mode().await?;
                                                                     ^0
 1582|      1|        Ok(json!({ "content": [{ "type": "text", "text": mode.to_string() }] }))
 1583|      1|    }
 1584|       |
 1585|      1|    async fn handle_ban_peers(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1586|      1|        let peers = args
 1587|      1|            .get("peers")
 1588|      1|            .and_then(|v| v.as_str())
 1589|      1|            .ok_or(anyhow::anyhow!("Missing peers"))?;
                                                                  ^0
 1590|      1|        client.ban_peers(peers).await?;
                                                   ^0
 1591|      1|        Ok(json!({ "content": [{ "type": "text", "text": "Peers banned successfully" }] }))
 1592|      1|    }
 1593|       |
 1594|      1|    async fn handle_create_category(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1595|      1|        let name = args
 1596|      1|            .get("name")
 1597|      1|            .and_then(|v| v.as_str())
 1598|      1|            .ok_or(anyhow::anyhow!("Missing name"))?;
                                                                 ^0
 1599|      1|        let save_path = args
 1600|      1|            .get("save_path")
 1601|      1|            .and_then(|v| v.as_str())
 1602|      1|            .ok_or(anyhow::anyhow!("Missing save_path"))?;
                                                                      ^0
 1603|      1|        client.create_category(name, save_path).await?;
 1604|      0|        Ok(json!({ "content": [{ "type": "text", "text": "Category created successfully" }] }))
 1605|      1|    }
 1606|       |
 1607|      1|    async fn handle_set_torrent_category(
 1608|      1|        &self,
 1609|      1|        client: &QBitClient,
 1610|      1|        args: &Value,
 1611|      1|    ) -> Result<Value> {
 1612|      1|        let hashes = args
 1613|      1|            .get("hashes")
 1614|      1|            .and_then(|v| v.as_str())
 1615|      1|            .ok_or(anyhow::anyhow!("Missing hashes"))?;
                                                                   ^0
 1616|      1|        let category = args
 1617|      1|            .get("category")
 1618|      1|            .and_then(|v| v.as_str())
 1619|      1|            .ok_or(anyhow::anyhow!("Missing category"))?;
                                                                     ^0
 1620|      1|        client.set_category(hashes, category).await?;
                                                                 ^0
 1621|      1|        Ok(json!({ "content": [{ "type": "text", "text": "Category set successfully" }] }))
 1622|      1|    }
 1623|       |
 1624|      1|    async fn handle_get_categories(&self, client: &QBitClient) -> Result<Value> {
 1625|      1|        let categories = client.get_categories().await?;
                                                                    ^0
 1626|      1|        let text = serde_json::to_string_pretty(&categories)?;
                                                                          ^0
 1627|      1|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 1628|      1|    }
 1629|       |
 1630|      1|    async fn handle_add_torrent_tags(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1631|      1|        let hashes = args
 1632|      1|            .get("hashes")
 1633|      1|            .and_then(|v| v.as_str())
 1634|      1|            .ok_or(anyhow::anyhow!("Missing hashes"))?;
                                                                   ^0
 1635|      1|        let tags = args
 1636|      1|            .get("tags")
 1637|      1|            .and_then(|v| v.as_str())
 1638|      1|            .ok_or(anyhow::anyhow!("Missing tags"))?;
                                                                 ^0
 1639|      1|        client.add_tags(hashes, tags).await?;
                                                         ^0
 1640|      1|        Ok(json!({ "content": [{ "type": "text", "text": "Tags added successfully" }] }))
 1641|      1|    }
 1642|       |
 1643|      1|    async fn handle_install_search_plugin(
 1644|      1|        &self,
 1645|      1|        client: &QBitClient,
 1646|      1|        args: &Value,
 1647|      1|    ) -> Result<Value> {
 1648|      1|        let url = args
 1649|      1|            .get("url")
 1650|      1|            .and_then(|v| v.as_str())
 1651|      1|            .ok_or(anyhow::anyhow!("Missing url"))?;
                                                                ^0
 1652|      1|        client.install_search_plugin(url).await?;
                                                             ^0
 1653|      1|        Ok(
 1654|      1|            json!({ "content": [{ "type": "text", "text": "Search plugin installed successfully" }] }),
 1655|      1|        )
 1656|      1|    }
 1657|       |
 1658|      1|    async fn handle_uninstall_search_plugin(
 1659|      1|        &self,
 1660|      1|        client: &QBitClient,
 1661|      1|        args: &Value,
 1662|      1|    ) -> Result<Value> {
 1663|      1|        let name = args
 1664|      1|            .get("name")
 1665|      1|            .and_then(|v| v.as_str())
 1666|      1|            .ok_or(anyhow::anyhow!("Missing name"))?;
                                                                 ^0
 1667|      1|        client.uninstall_search_plugin(name).await?;
                                                                ^0
 1668|      1|        Ok(
 1669|      1|            json!({ "content": [{ "type": "text", "text": "Search plugin uninstalled successfully" }] }),
 1670|      1|        )
 1671|      1|    }
 1672|       |
 1673|      1|    async fn handle_enable_search_plugin(
 1674|      1|        &self,
 1675|      1|        client: &QBitClient,
 1676|      1|        args: &Value,
 1677|      1|    ) -> Result<Value> {
 1678|      1|        let name = args
 1679|      1|            .get("name")
 1680|      1|            .and_then(|v| v.as_str())
 1681|      1|            .ok_or(anyhow::anyhow!("Missing name"))?;
                                                                 ^0
 1682|      1|        let enable = args
 1683|      1|            .get("enable")
 1684|      1|            .and_then(|v| v.as_bool())
 1685|      1|            .ok_or(anyhow::anyhow!("Missing enable"))?;
                                                                   ^0
 1686|      1|        client.enable_search_plugin(name, enable).await?;
                                                                     ^0
 1687|      1|        Ok(
 1688|      1|            json!({ "content": [{ "type": "text", "text": "Search plugin status updated successfully" }] }),
 1689|      1|        )
 1690|      1|    }
 1691|       |
 1692|      1|    async fn handle_update_search_plugins(&self, client: &QBitClient) -> Result<Value> {
 1693|      1|        client.update_search_plugins().await?;
                                                          ^0
 1694|      1|        Ok(
 1695|      1|            json!({ "content": [{ "type": "text", "text": "Search plugins updated successfully" }] }),
 1696|      1|        )
 1697|      1|    }
 1698|       |
 1699|      1|    async fn handle_get_search_plugins(&self, client: &QBitClient) -> Result<Value> {
 1700|      1|        let plugins = client.get_search_plugins().await?;
                                                                     ^0
 1701|      1|        let text = serde_json::to_string_pretty(&plugins)?;
                                                                       ^0
 1702|      1|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 1703|      1|    }
 1704|       |
 1705|      1|    async fn handle_add_rss_feed(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1706|      1|        let url = args
 1707|      1|            .get("url")
 1708|      1|            .and_then(|v| v.as_str())
 1709|      1|            .ok_or(anyhow::anyhow!("Missing url"))?;
                                                                ^0
 1710|      1|        let path = args
 1711|      1|            .get("path")
 1712|      1|            .and_then(|v| v.as_str())
 1713|      1|            .ok_or(anyhow::anyhow!("Missing path"))?;
                                                                 ^0
 1714|      1|        client.add_rss_feed(url, path).await?;
 1715|      0|        Ok(json!({ "content": [{ "type": "text", "text": "RSS feed added successfully" }] }))
 1716|      1|    }
 1717|       |
 1718|      1|    async fn handle_get_rss_feeds(&self, client: &QBitClient) -> Result<Value> {
 1719|      1|        let feeds = client.get_all_rss_feeds().await?;
                                                                  ^0
 1720|      1|        let text = serde_json::to_string_pretty(&feeds)?;
                                                                     ^0
 1721|      1|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 1722|      1|    }
 1723|       |
 1724|      1|    async fn handle_set_rss_rule(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1725|      1|        let name = args
 1726|      1|            .get("name")
 1727|      1|            .and_then(|v| v.as_str())
 1728|      1|            .ok_or(anyhow::anyhow!("Missing name"))?;
                                                                 ^0
 1729|      1|        let definition = args
 1730|      1|            .get("definition")
 1731|      1|            .and_then(|v| v.as_str())
 1732|      1|            .ok_or(anyhow::anyhow!("Missing definition"))?;
                                                                       ^0
 1733|      1|        client.set_rss_rule(name, definition).await?;
                                                                 ^0
 1734|      1|        Ok(json!({ "content": [{ "type": "text", "text": "RSS rule set successfully" }] }))
 1735|      1|    }
 1736|       |
 1737|      1|    async fn handle_get_rss_rules(&self, client: &QBitClient) -> Result<Value> {
 1738|      1|        let rules = client.get_all_rss_rules().await?;
                                                                  ^0
 1739|      1|        let text = serde_json::to_string_pretty(&rules)?;
                                                                     ^0
 1740|      1|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 1741|      1|    }
 1742|       |
 1743|      1|    async fn handle_get_app_preferences(&self, client: &QBitClient) -> Result<Value> {
 1744|      1|        let prefs = client.get_app_preferences().await?;
                                                                    ^0
 1745|      1|        let text = serde_json::to_string_pretty(&prefs)?;
                                                                     ^0
 1746|      1|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 1747|      1|    }
 1748|       |
 1749|      1|    async fn handle_set_app_preferences(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1750|      1|        let prefs_str = args
 1751|      1|            .get("preferences")
 1752|      1|            .and_then(|v| v.as_str())
 1753|      1|            .ok_or(anyhow::anyhow!("Missing preferences"))?;
                                                                        ^0
 1754|      1|        let prefs_val: serde_json::Value = serde_json::from_str(prefs_str)?;
                                                                                        ^0
 1755|      1|        client.set_app_preferences(&prefs_val).await?;
                                                                  ^0
 1756|      1|        Ok(
 1757|      1|            json!({ "content": [{ "type": "text", "text": "App preferences updated successfully" }] }),
 1758|      1|        )
 1759|      1|    }
 1760|       |
 1761|      1|    async fn handle_get_main_log(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1762|      1|        let severity = args
 1763|      1|            .get("severity")
 1764|      1|            .and_then(|v| v.as_str())
                                        ^0^0
 1765|      1|            .unwrap_or("all");
 1766|      1|        let last_id = args.get("last_id").and_then(|v| v.as_i64());
                                                                     ^0^0
 1767|      1|        let (normal, info, warning, critical) = match severity {
 1768|      1|            "info" => (false, true, false, false),
                                    ^0
 1769|      1|            "warning" => (false, false, true, false),
                                       ^0
 1770|      1|            "critical" => (false, false, false, true),
                                        ^0
 1771|      1|            _ => (true, true, true, true),
 1772|       |        };
 1773|      1|        let logs = client
 1774|      1|            .get_main_log(normal, info, warning, critical, last_id)
 1775|      1|            .await?;
                                ^0
 1776|      1|        let text = serde_json::to_string_pretty(&logs)?;
                                                                    ^0
 1777|      1|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 1778|      1|    }
 1779|       |
 1780|      1|    async fn handle_get_peer_log(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1781|      1|        let last_id = args.get("last_id").and_then(|v| v.as_i64());
                                                                     ^0^0
 1782|      1|        let logs = client.get_peer_log(last_id).await?;
                                                                   ^0
 1783|      1|        let text = serde_json::to_string_pretty(&logs)?;
                                                                    ^0
 1784|      1|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 1785|      1|    }
 1786|       |
 1787|      1|    async fn handle_get_app_version(&self, client: &QBitClient) -> Result<Value> {
 1788|      1|        let version = client.get_app_version().await?;
                                                                  ^0
 1789|      1|        Ok(json!({ "content": [{ "type": "text", "text": version }] }))
 1790|      1|    }
 1791|       |
 1792|      1|    async fn handle_get_build_info(&self, client: &QBitClient) -> Result<Value> {
 1793|      1|        let info = client.get_build_info().await?;
                                                              ^0
 1794|      1|        let text = serde_json::to_string_pretty(&info)?;
                                                                    ^0
 1795|      1|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 1796|      1|    }
 1797|       |
 1798|      1|    async fn handle_shutdown_app(&self, client: &QBitClient) -> Result<Value> {
 1799|      1|        client.shutdown_app().await?;
                                                 ^0
 1800|      1|        Ok(json!({ "content": [{ "type": "text", "text": "Shutdown command sent" }] }))
 1801|      1|    }
 1802|       |
 1803|      1|    async fn handle_wait_for_torrent_status(
 1804|      1|        &self,
 1805|      1|        client: &QBitClient,
 1806|      1|        args: &Value,
 1807|      1|    ) -> Result<Value> {
 1808|      1|        let hash = args
 1809|      1|            .get("hash")
 1810|      1|            .and_then(|v| v.as_str())
 1811|      1|            .ok_or(anyhow::anyhow!("Missing hash"))?;
                                                                 ^0
 1812|      1|        let target_status = args
 1813|      1|            .get("target_status")
 1814|      1|            .and_then(|v| v.as_str())
 1815|      1|            .ok_or(anyhow::anyhow!("Missing target_status"))?;
                                                                          ^0
 1816|      1|        let timeout = args
 1817|      1|            .get("timeout_seconds")
 1818|      1|            .and_then(|v| v.as_i64())
                                        ^0^0
 1819|      1|            .unwrap_or(60)
 1820|      1|            .clamp(1, 300);
 1821|       |
 1822|      1|        let start_time = std::time::Instant::now();
 1823|      1|        while start_time.elapsed().as_secs() < timeout as u64 {
 1824|      1|            let torrents = client.get_torrents_info(hash).await?;
                                                                             ^0
 1825|      1|            if let Some(t) = torrents.first() {
                                      ^0
 1826|      0|                if t.state == target_status {
 1827|      0|                    return Ok(
 1828|      0|                        json!({ "content": [{ "type": "text", "text": format!("Torrent reached target status: {}", target_status) }] }),
 1829|      0|                    );
 1830|      0|                }
 1831|       |            } else {
 1832|      1|                anyhow::bail!("Torrent not found: {}", hash);
 1833|       |            }
 1834|      0|            sleep(Duration::from_secs(2)).await;
 1835|       |        }
 1836|      0|        Ok(
 1837|      0|            json!({ "content": [{ "type": "text", "text": format!("Timed out waiting for status {}", target_status) }], "isError": true }),
 1838|      0|        )
 1839|      1|    }
 1840|       |
 1841|      1|    async fn handle_cleanup_completed(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1842|      1|        let min_ratio = args.get("min_ratio").and_then(|v| v.as_f64());
                                                                         ^0^0
 1843|      1|        let max_age_days = args.get("max_age_days").and_then(|v| v.as_i64());
                                                                               ^0^0
 1844|      1|        let delete_files = args
 1845|      1|            .get("delete_files")
 1846|      1|            .and_then(|v| v.as_bool())
 1847|      1|            .unwrap_or(false);
 1848|       |
 1849|      1|        let torrents = client
 1850|      1|            .get_torrent_list(Some("completed"), None, None, None, None, None, None)
 1851|      1|            .await?;
                                ^0
 1852|       |
 1853|      1|        let now = std::time::SystemTime::now()
 1854|      1|            .duration_since(std::time::UNIX_EPOCH)?
                                                                ^0
 1855|      1|            .as_secs() as i64;
 1856|       |
 1857|      1|        let to_delete: Vec<String> = torrents
 1858|      1|            .into_iter()
 1859|      1|            .filter(|t| {
 1860|      1|                let mut should_delete = false;
 1861|      1|                if let Some(r) = min_ratio {
                                          ^0
 1862|      0|                    should_delete = t.ratio >= r;
 1863|      1|                }
 1864|      1|                if let Some(age_days) = max_age_days {
                                          ^0
 1865|      0|                    let age_secs = age_days * 24 * 3600;
 1866|      0|                    if t.completion_on > 0 && (now - t.completion_on) >= age_secs {
 1867|      0|                        should_delete = true;
 1868|      0|                    }
 1869|      1|                }
 1870|       |                // If neither is specified, we don't delete anything automatically
 1871|       |                // to avoid accidental wipes of all completed torrents.
 1872|       |                // UNLESS the user explicitly wants to delete all completed.
 1873|       |                // But let's require at least one condition for safety in this macro.
 1874|      1|                if min_ratio.is_none() && max_age_days.is_none() {
 1875|      1|                    return false;
 1876|      0|                }
 1877|      0|                should_delete
 1878|      1|            })
 1879|      1|            .map(|t| t.hash)
 1880|      1|            .collect();
 1881|       |
 1882|      1|        if to_delete.is_empty() {
 1883|      1|            return Ok(
 1884|      1|                json!({ "content": [{ "type": "text", "text": "No torrents matched the cleanup criteria." }] }),
 1885|      1|            );
 1886|      0|        }
 1887|       |
 1888|      0|        let count = to_delete.len();
 1889|      0|        let hashes = to_delete.join("|");
 1890|      0|        client.delete_torrents(&hashes, delete_files).await?;
 1891|       |
 1892|      0|        Ok(
 1893|      0|            json!({ "content": [{ "type": "text", "text": format!("Successfully cleaned up {} torrents.", count) }] }),
 1894|      0|        )
 1895|      1|    }
 1896|       |
 1897|      1|    async fn handle_mass_rename(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 1898|      1|        let hash = args
 1899|      1|            .get("hash")
 1900|      1|            .and_then(|v| v.as_str())
 1901|      1|            .ok_or(anyhow::anyhow!("Missing hash"))?;
                                                                 ^0
 1902|      1|        let pattern = args
 1903|      1|            .get("pattern")
 1904|      1|            .and_then(|v| v.as_str())
 1905|      1|            .ok_or(anyhow::anyhow!("Missing pattern"))?;
                                                                    ^0
 1906|      1|        let replacement = args
 1907|      1|            .get("replacement")
 1908|      1|            .and_then(|v| v.as_str())
 1909|      1|            .ok_or(anyhow::anyhow!("Missing replacement"))?;
                                                                        ^0
 1910|       |
 1911|      1|        let re = Regex::new(pattern)?;
                                                  ^0
 1912|      1|        let files = client.get_torrent_files(hash).await?;
                          ^0
 1913|       |
 1914|      0|        let mut rename_count = 0;
 1915|      0|        for file in files {
 1916|      0|            if re.is_match(&file.name) {
 1917|      0|                let new_name = re.replace_all(&file.name, replacement).to_string();
 1918|      0|                if new_name != file.name {
 1919|      0|                    client.rename_file(hash, &file.name, &new_name).await?;
 1920|      0|                    rename_count += 1;
 1921|      0|                }
 1922|      0|            }
 1923|       |        }
 1924|       |
 1925|      0|        Ok(
 1926|      0|            json!({ "content": [{ "type": "text", "text": format!("Successfully renamed {} files.", rename_count) }] }),
 1927|      0|        )
 1928|      1|    }
 1929|       |
 1930|      1|    async fn handle_set_torrent_share_limits(
 1931|      1|        &self,
 1932|      1|        client: &QBitClient,
 1933|      1|        args: &Value,
 1934|      1|    ) -> Result<Value> {
 1935|      1|        let hashes = args
 1936|      1|            .get("hashes")
 1937|      1|            .and_then(|v| v.as_str())
 1938|      1|            .ok_or(anyhow::anyhow!("Missing hashes"))?;
                                                                   ^0
 1939|      1|        let ratio_limit = args
 1940|      1|            .get("ratio_limit")
 1941|      1|            .and_then(|v| v.as_f64())
 1942|      1|            .ok_or(anyhow::anyhow!("Missing ratio_limit"))?;
                                                                        ^0
 1943|      1|        let seeding_time_limit = args
 1944|      1|            .get("seeding_time_limit")
 1945|      1|            .and_then(|v| v.as_i64())
 1946|      1|            .ok_or(anyhow::anyhow!("Missing seeding_time_limit"))?;
                                                                               ^0
 1947|      1|        let inactive_seeding_time_limit = args
 1948|      1|            .get("inactive_seeding_time_limit")
 1949|      1|            .and_then(|v| v.as_i64());
                                        ^0^0
 1950|       |
 1951|      1|        client
 1952|      1|            .set_torrent_share_limits(
 1953|      1|                hashes,
 1954|      1|                ratio_limit,
 1955|      1|                seeding_time_limit,
 1956|      1|                inactive_seeding_time_limit,
 1957|      1|            )
 1958|      1|            .await?;
                                ^0
 1959|      1|        Ok(
 1960|      1|            json!({ "content": [{ "type": "text", "text": "Torrent share limits updated successfully" }] }),
 1961|      1|        )
 1962|      1|    }
 1963|       |
 1964|      1|    async fn handle_set_torrent_speed_limits(
 1965|      1|        &self,
 1966|      1|        client: &QBitClient,
 1967|      1|        args: &Value,
 1968|      1|    ) -> Result<Value> {
 1969|      1|        let hashes = args
 1970|      1|            .get("hashes")
 1971|      1|            .and_then(|v| v.as_str())
 1972|      1|            .ok_or(anyhow::anyhow!("Missing hashes"))?;
                                                                   ^0
 1973|       |
 1974|      1|        if let Some(limit) = args.get("dl_limit").and_then(|v| v.as_i64()) {
                                  ^0                                         ^0^0
 1975|      0|            client.set_torrent_download_limit(hashes, limit).await?;
 1976|      1|        }
 1977|      1|        if let Some(limit) = args.get("up_limit").and_then(|v| v.as_i64()) {
                                  ^0                                         ^0^0
 1978|      0|            client.set_torrent_upload_limit(hashes, limit).await?;
 1979|      1|        }
 1980|       |
 1981|      1|        Ok(
 1982|      1|            json!({ "content": [{ "type": "text", "text": "Torrent speed limits updated successfully" }] }),
 1983|      1|        )
 1984|      1|    }
 1985|       |
 1986|      1|    async fn handle_find_duplicates(&self, client: &QBitClient) -> Result<Value> {
 1987|      1|        let torrents = client
 1988|      1|            .get_torrent_list(None, None, None, None, None, None, None)
 1989|      1|            .await?;
                                ^0
 1990|       |
 1991|      1|        let mut names: std::collections::HashMap<String, Vec<crate::models::Torrent>> =
 1992|      1|            std::collections::HashMap::new();
 1993|       |
 1994|      1|        for t in torrents {
 1995|      1|            names.entry(t.name.clone()).or_default().push(t);
 1996|      1|        }
 1997|       |
 1998|      1|        let duplicates: Vec<Value> = names
 1999|      1|            .into_iter()
 2000|      1|            .filter(|(_, v)| v.len() > 1)
 2001|      1|            .map(|(name, v)| {
                                           ^0
 2002|      0|                json!({
 2003|      0|                    "name": name,
 2004|      0|                    "count": v.len(),
 2005|      0|                    "torrents": v.into_iter().map(|t| json!({
 2006|      0|                        "hash": t.hash,
 2007|      0|                        "size": t.size_bytes,
 2008|      0|                        "progress": t.progress,
 2009|      0|                        "state": t.state
 2010|      0|                    })).collect::<Vec<Value>>()
 2011|       |                })
 2012|      0|            })
 2013|      1|            .collect();
 2014|       |
 2015|      1|        if duplicates.is_empty() {
 2016|      1|            return Ok(
 2017|      1|                json!({ "content": [{ "type": "text", "text": "No duplicate torrents found." }] }),
 2018|      1|            );
 2019|      0|        }
 2020|       |
 2021|      0|        let text = serde_json::to_string_pretty(&duplicates)?;
 2022|      0|        Ok(json!({ "content": [{ "type": "text", "text": text }] }))
 2023|      1|    }
 2024|       |
 2025|      1|    async fn handle_toggle_sequential_download(
 2026|      1|        &self,
 2027|      1|        client: &QBitClient,
 2028|      1|        args: &Value,
 2029|      1|    ) -> Result<Value> {
 2030|      1|        let hashes = args
 2031|      1|            .get("hashes")
 2032|      1|            .and_then(|v| v.as_str())
 2033|      1|            .ok_or(anyhow::anyhow!("Missing hashes"))?;
                                                                   ^0
 2034|      1|        client.toggle_sequential_download(hashes).await?;
                                                                     ^0
 2035|      1|        Ok(
 2036|      1|            json!({ "content": [{ "type": "text", "text": "Sequential download toggled successfully" }] }),
 2037|      1|        )
 2038|      1|    }
 2039|       |
 2040|      1|    async fn handle_toggle_first_last_piece_priority(
 2041|      1|        &self,
 2042|      1|        client: &QBitClient,
 2043|      1|        args: &Value,
 2044|      1|    ) -> Result<Value> {
 2045|      1|        let hashes = args
 2046|      1|            .get("hashes")
 2047|      1|            .and_then(|v| v.as_str())
 2048|      1|            .ok_or(anyhow::anyhow!("Missing hashes"))?;
                                                                   ^0
 2049|      1|        client.toggle_first_last_piece_priority(hashes).await?;
                                                                           ^0
 2050|      1|        Ok(
 2051|      1|            json!({ "content": [{ "type": "text", "text": "First/last piece priority toggled successfully" }] }),
 2052|      1|        )
 2053|      1|    }
 2054|       |
 2055|      1|    async fn handle_set_force_start(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 2056|      1|        let hashes = args
 2057|      1|            .get("hashes")
 2058|      1|            .and_then(|v| v.as_str())
 2059|      1|            .ok_or(anyhow::anyhow!("Missing hashes"))?;
                                                                   ^0
 2060|      1|        let value = args
 2061|      1|            .get("value")
 2062|      1|            .and_then(|v| v.as_bool())
 2063|      1|            .ok_or(anyhow::anyhow!("Missing value"))?;
                                                                  ^0
 2064|      1|        client.set_force_start(hashes, value).await?;
                                                                 ^0
 2065|      1|        Ok(
 2066|      1|            json!({ "content": [{ "type": "text", "text": "Force start status updated successfully" }] }),
 2067|      1|        )
 2068|      1|    }
 2069|       |
 2070|      1|    async fn handle_set_super_seeding(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 2071|      1|        let hashes = args
 2072|      1|            .get("hashes")
 2073|      1|            .and_then(|v| v.as_str())
 2074|      1|            .ok_or(anyhow::anyhow!("Missing hashes"))?;
                                                                   ^0
 2075|      1|        let value = args
 2076|      1|            .get("value")
 2077|      1|            .and_then(|v| v.as_bool())
 2078|      1|            .ok_or(anyhow::anyhow!("Missing value"))?;
                                                                  ^0
 2079|      1|        client.set_super_seeding(hashes, value).await?;
                                                                   ^0
 2080|      1|        Ok(
 2081|      1|            json!({ "content": [{ "type": "text", "text": "Super seeding status updated successfully" }] }),
 2082|      1|        )
 2083|      1|    }
 2084|       |
 2085|      1|    async fn handle_add_trackers(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 2086|      1|        let hashes = args
 2087|      1|            .get("hashes")
 2088|      1|            .and_then(|v| v.as_str())
 2089|      1|            .ok_or(anyhow::anyhow!("Missing hashes"))?;
                                                                   ^0
 2090|      1|        let urls = args
 2091|      1|            .get("urls")
 2092|      1|            .and_then(|v| v.as_str())
 2093|      1|            .ok_or(anyhow::anyhow!("Missing urls"))?;
                                                                 ^0
 2094|      1|        client.add_trackers(hashes, urls).await?;
 2095|      0|        Ok(json!({ "content": [{ "type": "text", "text": "Trackers added successfully" }] }))
 2096|      1|    }
 2097|       |
 2098|      1|    async fn handle_edit_tracker(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 2099|      1|        let hash = args
 2100|      1|            .get("hash")
 2101|      1|            .and_then(|v| v.as_str())
 2102|      1|            .ok_or(anyhow::anyhow!("Missing hash"))?;
                                                                 ^0
 2103|      1|        let orig_url = args
 2104|      1|            .get("orig_url")
 2105|      1|            .and_then(|v| v.as_str())
 2106|      1|            .ok_or(anyhow::anyhow!("Missing orig_url"))?;
                                                                     ^0
 2107|      1|        let new_url = args
 2108|      1|            .get("new_url")
 2109|      1|            .and_then(|v| v.as_str())
 2110|      1|            .ok_or(anyhow::anyhow!("Missing new_url"))?;
                                                                    ^0
 2111|      1|        client.edit_tracker(hash, orig_url, new_url).await?;
 2112|      0|        Ok(json!({ "content": [{ "type": "text", "text": "Tracker edited successfully" }] }))
 2113|      1|    }
 2114|       |
 2115|      1|    async fn handle_remove_trackers(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 2116|      1|        let hashes = args
 2117|      1|            .get("hashes")
 2118|      1|            .and_then(|v| v.as_str())
 2119|      1|            .ok_or(anyhow::anyhow!("Missing hashes"))?;
                                                                   ^0
 2120|      1|        let urls = args
 2121|      1|            .get("urls")
 2122|      1|            .and_then(|v| v.as_str())
 2123|      1|            .ok_or(anyhow::anyhow!("Missing urls"))?;
                                                                 ^0
 2124|      1|        client.remove_trackers(hashes, urls).await?;
 2125|      0|        Ok(json!({ "content": [{ "type": "text", "text": "Trackers removed successfully" }] }))
 2126|      1|    }
 2127|       |
 2128|      1|    async fn handle_rename_folder(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 2129|      1|        let hash = args
 2130|      1|            .get("hash")
 2131|      1|            .and_then(|v| v.as_str())
 2132|      1|            .ok_or(anyhow::anyhow!("Missing hash"))?;
                                                                 ^0
 2133|      1|        let old_path = args
 2134|      1|            .get("old_path")
 2135|      1|            .and_then(|v| v.as_str())
 2136|      1|            .ok_or(anyhow::anyhow!("Missing old_path"))?;
                                                                     ^0
 2137|      1|        let new_path = args
 2138|      1|            .get("new_path")
 2139|      1|            .and_then(|v| v.as_str())
 2140|      1|            .ok_or(anyhow::anyhow!("Missing new_path"))?;
                                                                     ^0
 2141|      1|        client.rename_folder(hash, old_path, new_path).await?;
 2142|      0|        Ok(json!({ "content": [{ "type": "text", "text": "Folder renamed successfully" }] }))
 2143|      1|    }
 2144|       |
 2145|      1|    async fn handle_set_file_priority(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 2146|      1|        let hash = args
 2147|      1|            .get("hash")
 2148|      1|            .and_then(|v| v.as_str())
 2149|      1|            .ok_or(anyhow::anyhow!("Missing hash"))?;
                                                                 ^0
 2150|      1|        let id = args
 2151|      1|            .get("id")
 2152|      1|            .and_then(|v| v.as_str())
 2153|      1|            .ok_or(anyhow::anyhow!("Missing id"))?;
                                                               ^0
 2154|      1|        let priority = args
 2155|      1|            .get("priority")
 2156|      1|            .and_then(|v| v.as_i64())
 2157|      1|            .ok_or(anyhow::anyhow!("Missing priority"))? as i32;
                                                                     ^0
 2158|      1|        client.set_file_priority(hash, id, priority).await?;
 2159|      0|        Ok(json!({ "content": [{ "type": "text", "text": "File priority updated successfully" }] }))
 2160|      1|    }
 2161|       |
 2162|      1|    async fn handle_remove_categories(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 2163|      1|        let categories = args
 2164|      1|            .get("categories")
 2165|      1|            .and_then(|v| v.as_str())
 2166|      1|            .ok_or(anyhow::anyhow!("Missing categories"))?;
                                                                       ^0
 2167|      1|        client.remove_categories(categories).await?;
                                                                ^0
 2168|      1|        Ok(json!({ "content": [{ "type": "text", "text": "Categories removed successfully" }] }))
 2169|      1|    }
 2170|       |
 2171|      1|    async fn handle_remove_tags(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 2172|      1|        let hashes = args
 2173|      1|            .get("hashes")
 2174|      1|            .and_then(|v| v.as_str())
 2175|      1|            .ok_or(anyhow::anyhow!("Missing hashes"))?;
                                                                   ^0
 2176|      1|        let tags = args
 2177|      1|            .get("tags")
 2178|      1|            .and_then(|v| v.as_str())
 2179|      1|            .ok_or(anyhow::anyhow!("Missing tags"))?;
                                                                 ^0
 2180|      1|        client.remove_tags(hashes, tags).await?;
                                                            ^0
 2181|      1|        Ok(
 2182|      1|            json!({ "content": [{ "type": "text", "text": "Tags removed from torrents successfully" }] }),
 2183|      1|        )
 2184|      1|    }
 2185|       |
 2186|      1|    async fn handle_create_tags(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 2187|      1|        let tags = args
 2188|      1|            .get("tags")
 2189|      1|            .and_then(|v| v.as_str())
 2190|      1|            .ok_or(anyhow::anyhow!("Missing tags"))?;
                                                                 ^0
 2191|      1|        client.create_tags(tags).await?;
                                                    ^0
 2192|      1|        Ok(json!({ "content": [{ "type": "text", "text": "Tags created successfully" }] }))
 2193|      1|    }
 2194|       |
 2195|      1|    async fn handle_delete_tags(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 2196|      1|        let tags = args
 2197|      1|            .get("tags")
 2198|      1|            .and_then(|v| v.as_str())
 2199|      1|            .ok_or(anyhow::anyhow!("Missing tags"))?;
                                                                 ^0
 2200|      1|        client.delete_tags(tags).await?;
                                                    ^0
 2201|      1|        Ok(json!({ "content": [{ "type": "text", "text": "Tags deleted successfully" }] }))
 2202|      1|    }
 2203|       |
 2204|      1|    async fn handle_move_rss_item(&self, client: &QBitClient, args: &Value) -> Result<Value> {
 2205|      1|        let item_path = args
 2206|      1|            .get("item_path")
 2207|      1|            .and_then(|v| v.as_str())
 2208|      1|            .ok_or(anyhow::anyhow!("Missing item_path"))?;
                                                                      ^0
 2209|      1|        let dest_path = args
 2210|      1|            .get("dest_path")
 2211|      1|            .and_then(|v| v.as_str())
 2212|      1|            .ok_or(anyhow::anyhow!("Missing dest_path"))?;
                                                                      ^0
 2213|      1|        client.move_rss_item(item_path, dest_path).await?;
 2214|      0|        Ok(json!({ "content": [{ "type": "text", "text": "RSS item moved successfully" }] }))
 2215|      1|    }
 2216|       |
 2217|      2|    pub fn start_event_loop(&self, interval_ms: u64) {
 2218|      2|        let server = self.clone();
 2219|      2|        tokio::spawn(async move {
 2220|      2|            server.event_loop(interval_ms).await;
 2221|      0|        });
 2222|      2|    }
 2223|       |
 2224|      2|    async fn event_loop(&self, interval_ms: u64) {
 2225|      2|        let mut last_rids: HashMap<String, i64> = HashMap::new();
 2226|      2|        let mut notified_finished: HashMap<String, std::collections::HashSet<String>> =
 2227|      2|            HashMap::new();
 2228|       |
 2229|      2|        for name in self.clients.keys() {
 2230|      2|            last_rids.insert(name.clone(), 0);
 2231|      2|            notified_finished.insert(name.clone(), std::collections::HashSet::new());
 2232|      2|        }
 2233|       |
 2234|       |        loop {
 2235|      5|            sleep(Duration::from_millis(interval_ms)).await;
 2236|      3|            for (name, client) in &self.clients {
 2237|      3|                let rid = *last_rids.get(name).unwrap_or(&0);
 2238|      3|                match client.get_main_data(rid).await {
 2239|      3|                    Ok(data) => {
 2240|      3|                        last_rids.insert(name.clone(), data.rid);
 2241|       |
 2242|       |                        // Track finished torrents to notify only once
 2243|      3|                        if let Some(torrents) = data.torrents {
                                                  ^1
 2244|      1|                            for (hash, torrent_val) in torrents {
 2245|      1|                                let progress = torrent_val.get("progress").and_then(|p| p.as_f64());
 2246|      1|                                let state = torrent_val.get("state").and_then(|s| s.as_str());
 2247|       |
 2248|       |                                // "uploading", "stalledUP", "queuedUP", "forcedUP" usually mean finished downloading
 2249|      1|                                let is_finished_state = state.is_some_and(|s| {
 2250|      1|                                    s == "uploading"
 2251|      1|                                        || s == "stalledUP"
 2252|      0|                                        || s == "queuedUP"
 2253|      0|                                        || s == "forcedUP"
 2254|      1|                                });
 2255|       |
 2256|      1|                                if progress.is_some_and(|p| p >= 1.0) || is_finished_state {
                                                                                       ^0
 2257|      1|                                    let already_notified =
 2258|      1|                                        notified_finished.get_mut(name).unwrap().contains(&hash);
 2259|      1|                                    if !already_notified {
 2260|      1|                                        let torrent_name = torrent_val
 2261|      1|                                            .get("name")
 2262|      1|                                            .and_then(|n| n.as_str())
 2263|      1|                                            .unwrap_or(&hash);
 2264|      1|                                        info!(
 2265|       |                                            "Notification: Torrent '{}' finished on {}",
 2266|       |                                            torrent_name, name
 2267|       |                                        );
 2268|       |
 2269|       |                                        // Custom notification
 2270|      1|                                        self.push_notification(
 2271|      1|                                            "notifications/torrent_finished",
 2272|      1|                                            json!({
 2273|      1|                                                "instance": name,
 2274|      1|                                                "hash": hash,
 2275|      1|                                                "name": torrent_name
 2276|       |                                            }),
 2277|       |                                        );
 2278|       |
 2279|       |                                        // Standard resource update notification
 2280|      1|                                        self.push_notification(
 2281|      1|                                                    "notifications/resources/updated",
 2282|      1|                                                    json!({ "uri": format!("qbittorrent://{}/torrents", name) }),
 2283|       |                                                );
 2284|       |
 2285|      1|                                        notified_finished
 2286|      1|                                            .get_mut(name)
 2287|      1|                                            .unwrap()
 2288|      1|                                            .insert(hash.clone());
 2289|      0|                                    }
 2290|      0|                                }
 2291|       |                            }
 2292|      2|                        }
 2293|       |                    }
 2294|      0|                    Err(e) => error!("Polling error for instance {}: {}", name, e),
 2295|       |                }
 2296|       |            }
 2297|       |        }
 2298|       |    }
 2299|       |}
 2300|       |
 2301|       |#[cfg(test)]
 2302|       |mod tests {
 2303|       |    use super::*;
 2304|       |
 2305|       |    #[tokio::test]
 2306|      1|    async fn test_rules_of_engagement_prompt() {
 2307|      1|        let client = QBitClient::new("http://localhost:8080", "admin", "adminadmin", false);
 2308|      1|        let mut clients = HashMap::new();
 2309|      1|        clients.insert("default".to_string(), client);
 2310|      1|        let server = McpServer::new(clients, false);
 2311|       |
 2312|       |        // 1. Verify prompt is listed
 2313|      1|        let list_req = JsonRpcRequest {
 2314|      1|            jsonrpc: "2.0".to_string(),
 2315|      1|            method: "prompts/list".to_string(),
 2316|      1|            params: None,
 2317|      1|            id: Some(json!(1)),
 2318|      1|        };
 2319|      1|        let list_resp = server.handle_request(list_req).await.unwrap();
 2320|      1|        let prompts = list_resp.get("prompts").unwrap().as_array().unwrap();
 2321|      5|        let rules_prompt = prompts.iter().find(|p| p["name"] == "rules-of-engagement");
                          ^1             ^1             ^1
 2322|      1|        assert!(rules_prompt.is_some());
 2323|       |
 2324|       |        // 2. Verify prompt content
 2325|      1|        let get_req = JsonRpcRequest {
 2326|      1|            jsonrpc: "2.0".to_string(),
 2327|      1|            method: "prompts/get".to_string(),
 2328|      1|            params: Some(json!({ "name": "rules-of-engagement" })),
 2329|      1|            id: Some(json!(2)),
 2330|      1|        };
 2331|      1|        let get_resp = server.handle_request(get_req).await.unwrap();
 2332|      1|        let messages = get_resp.get("messages").unwrap().as_array().unwrap();
 2333|       |
 2334|       |        // Check for the rules message
 2335|      2|        let rules_msg = messages.iter().find(|m| m["role"] == "assistant").unwrap();
                          ^1          ^1              ^1                                 ^1
 2336|      1|        let text = rules_msg["content"]["text"].as_str().unwrap();
 2337|       |
 2338|      1|        assert!(text.contains("State Verification"));
 2339|      1|        assert!(text.contains("Destructive Actions"));
 2340|      1|        assert!(text.contains("Search Etiquette"));
 2341|      1|        assert!(text.contains("Error Handling"));
 2342|      1|        assert!(text.contains("Idempotency"));
 2343|      1|        assert!(text.contains("Semantic Feedback"));
 2344|      1|        assert!(text.contains("Security"));
 2345|      1|    }
 2346|       |
 2347|       |    #[tokio::test]
 2348|      1|    async fn test_tool_call_routing() {
 2349|      1|        let client = QBitClient::new("http://localhost:8080", "admin", "adminadmin", false);
 2350|      1|        let mut clients = HashMap::new();
 2351|      1|        clients.insert("default".to_string(), client);
 2352|      1|        let server = McpServer::new(clients, false);
 2353|       |
 2354|       |        // Test all available tools to verify routing logic
 2355|      1|        let tools_to_test = vec![
 2356|      1|            ("list_torrents", json!({})),
 2357|      1|            ("add_torrent", json!({ "url": "magnet:?xt=urn:btih:..." })),
 2358|      1|            ("pause_torrent", json!({ "hash": "abc" })),
 2359|      1|            ("resume_torrent", json!({ "hash": "abc" })),
 2360|      1|            ("delete_torrent", json!({ "hash": "abc", "delete_files": false })),
 2361|      1|            ("reannounce_torrent", json!({ "hash": "abc" })),
 2362|      1|            ("recheck_torrent", json!({ "hash": "abc" })),
 2363|      1|            ("get_torrent_files", json!({ "hash": "abc" })),
 2364|      1|            ("get_torrent_properties", json!({ "hash": "abc" })),
 2365|      1|            ("create_category", json!({ "name": "test", "save_path": "/tmp" })),
 2366|      1|            ("set_torrent_category", json!({ "hashes": "abc", "category": "test" })),
 2367|      1|            ("get_categories", json!({})),
 2368|      1|            ("add_torrent_tags", json!({ "hashes": "abc", "tags": "t1" })),
 2369|      1|            ("wait_for_torrent_status", json!({ "hash": "abc", "target_status": "downloading" })),
 2370|      1|            ("cleanup_completed", json!({ "delete_files": false })),
 2371|      1|            ("mass_rename", json!({ "hash": "abc", "pattern": ".*", "replacement": "new" })),
 2372|      1|            ("find_duplicates", json!({})),
 2373|      1|            ("set_torrent_share_limits", json!({ "hashes": "abc", "ratio_limit": 1.0, "seeding_time_limit": 60 })),
 2374|      1|            ("set_torrent_speed_limits", json!({ "hashes": "abc" })),
 2375|      1|            ("toggle_sequential_download", json!({ "hashes": "abc" })),
 2376|      1|            ("toggle_first_last_piece_priority", json!({ "hashes": "abc" })),
 2377|      1|            ("set_force_start", json!({ "hashes": "abc", "value": true })),
 2378|      1|            ("set_super_seeding", json!({ "hashes": "abc", "value": true })),
 2379|      1|            ("add_trackers", json!({ "hashes": "abc", "urls": "http://t.com" })),
 2380|      1|            ("edit_tracker", json!({ "hash": "abc", "orig_url": "u1", "new_url": "u2" })),
 2381|      1|            ("remove_trackers", json!({ "hashes": "abc", "urls": "u1" })),
 2382|      1|            ("rename_folder", json!({ "hash": "abc", "old_path": "p1", "new_path": "p2" })),
 2383|      1|            ("set_file_priority", json!({ "hash": "abc", "id": "0", "priority": 1 })),
 2384|      1|            ("remove_categories", json!({ "categories": "c1" })),
 2385|      1|            ("remove_tags", json!({ "hashes": "abc", "tags": "t1" })),
 2386|      1|            ("create_tags", json!({ "tags": "t1" })),
 2387|      1|            ("delete_tags", json!({ "tags": "t1" })),
 2388|      1|            ("search_torrents", json!({ "query": "linux" })),
 2389|      1|            ("install_search_plugin", json!({ "url": "http://p.com" })),
 2390|      1|            ("uninstall_search_plugin", json!({ "name": "p1" })),
 2391|      1|            ("enable_search_plugin", json!({ "name": "p1", "enable": true })),
 2392|      1|            ("update_search_plugins", json!({})),
 2393|      1|            ("get_search_plugins", json!({})),
 2394|      1|            ("add_rss_feed", json!({ "url": "http://r.com", "path": "p1" })),
 2395|      1|            ("get_rss_feeds", json!({})),
 2396|      1|            ("set_rss_rule", json!({ "name": "r1", "definition": "{}" })),
 2397|      1|            ("get_rss_rules", json!({})),
 2398|      1|            ("move_rss_item", json!({ "item_path": "p1", "dest_path": "p2" })),
 2399|      1|            ("get_global_transfer_info", json!({})),
 2400|      1|            ("set_global_transfer_limits", json!({})),
 2401|      1|            ("toggle_alternative_speed_limits", json!({})),
 2402|      1|            ("get_speed_limits_mode", json!({})),
 2403|      1|            ("ban_peers", json!({ "peers": "1.1.1.1:80" })),
 2404|      1|            ("get_app_preferences", json!({})),
 2405|      1|            ("set_app_preferences", json!({ "preferences": "{}" })),
 2406|      1|            ("get_main_log", json!({})),
 2407|      1|            ("get_peer_log", json!({})),
 2408|      1|            ("get_app_version", json!({})),
 2409|      1|            ("get_build_info", json!({})),
 2410|      1|            ("shutdown_app", json!({})),
 2411|       |        ];
 2412|       |
 2413|     55|        for (name, args) in tools_to_test {
                      ^1                  ^1
 2414|     55|            let req = JsonRpcRequest {
 2415|     55|                jsonrpc: "2.0".to_string(),
 2416|     55|                method: "tools/call".to_string(),
 2417|     55|                params: Some(json!({ "name": name, "arguments": args })),
 2418|     55|                id: Some(json!(1)),
 2419|     55|            };
 2420|      1|            
 2421|     55|            let resp = server.handle_request(req).await;
 2422|     55|            if let Ok(r) = resp {
                                    ^43
 2423|     43|                if let Some(error) = r.get("error") {
                                          ^0
 2424|      1|                    assert_ne!(error["message"], "Method not found", "Tool {} not found in routing", name);
                                  ^0         ^0
 2425|      1|                    assert_ne!(error["message"], format!("Unknown tool: {}", name), "Tool {} not found in tool mapping", name);
                                  ^0         ^0                ^0
 2426|     43|                }
 2427|     12|            }
 2428|      1|        }
 2429|      1|    }
 2430|       |
 2431|       |    #[tokio::test]
 2432|      1|    async fn test_resource_routing() {
 2433|      1|        let client = QBitClient::new("http://localhost:8080", "admin", "adminadmin", false);
 2434|      1|        let mut clients = HashMap::new();
 2435|      1|        clients.insert("default".to_string(), client);
 2436|      1|        let server = McpServer::new(clients, false);
 2437|       |
 2438|      1|        let uris = vec![
 2439|       |            "qbittorrent://default/torrents",
 2440|      1|            "qbittorrent://default/transfer",
 2441|      1|            "qbittorrent://default/categories",
 2442|       |        ];
 2443|       |
 2444|      3|        for uri in uris {
                      ^1         ^1
 2445|      3|            let req = JsonRpcRequest {
 2446|      3|                jsonrpc: "2.0".to_string(),
 2447|      3|                method: "resources/read".to_string(),
 2448|      3|                params: Some(json!({ "uri": uri })),
 2449|      3|                id: Some(json!(1)),
 2450|      3|            };
 2451|      3|            let resp = server.handle_request(req).await.unwrap();
 2452|      3|            if let Some(error) = resp.get("error") {
                                      ^0
 2453|      1|                assert_ne!(error["message"], format!("Resource not found: {}", uri));
                              ^0         ^0                ^0
 2454|      3|            }
 2455|      1|        }
 2456|      1|    }
 2457|       |
 2458|       |    #[tokio::test]
 2459|      1|    async fn test_event_loop_init() {
 2460|      1|        let client = QBitClient::new("http://localhost:8080", "admin", "adminadmin", false);
 2461|      1|        let mut clients = HashMap::new();
 2462|      1|        clients.insert("default".to_string(), client);
 2463|      1|        let server = McpServer::new(clients, false);
 2464|       |
 2465|       |        // Test start_event_loop doesn't panic
 2466|      1|        server.start_event_loop(10);
 2467|       |        // Give it a tiny bit of time to run
 2468|      1|        sleep(Duration::from_millis(50)).await;
 2469|      1|    }
 2470|       |
 2471|       |    #[test]
 2472|      1|    fn test_push_notification() {
 2473|      1|        let clients = HashMap::new();
 2474|      1|        let server = McpServer::new(clients, false);
 2475|      1|        server.push_notification("test_method", json!({"param": "val"}));
 2476|       |        
 2477|      1|        let state = server.state.lock().unwrap();
 2478|      1|        assert_eq!(state.notification_queue.len(), 1);
 2479|      1|        assert_eq!(state.notification_queue[0]["method"], "test_method");
 2480|      1|    }
 2481|       |
 2482|       |    #[tokio::test]
 2483|      1|    async fn test_handle_request_errors() {
 2484|      1|        let clients = HashMap::new();
 2485|      1|        let server = McpServer::new(clients, false);
 2486|       |
 2487|       |        // Unknown method
 2488|      1|        let req = JsonRpcRequest {
 2489|      1|            jsonrpc: "2.0".to_string(),
 2490|      1|            method: "unknown_method".to_string(),
 2491|      1|            params: None,
 2492|      1|            id: Some(json!(1)),
 2493|      1|        };
 2494|      1|        let result = server.handle_request(req).await;
 2495|      1|        assert!(result.is_err());
 2496|       |
 2497|       |        // Missing params for prompts/get
 2498|      1|        let req = JsonRpcRequest {
 2499|      1|            jsonrpc: "2.0".to_string(),
 2500|      1|            method: "prompts/get".to_string(),
 2501|      1|            params: None,
 2502|      1|            id: Some(json!(1)),
 2503|      1|        };
 2504|      1|        let result = server.handle_request(req).await;
 2505|      1|        assert!(result.is_err());
 2506|      1|    }
 2507|       |
 2508|       |    #[test]
 2509|      1|    fn test_resource_definitions() {
 2510|      1|        let mut clients = HashMap::new();
 2511|      1|        clients.insert("test".to_string(), QBitClient::new("http://localhost", "a", "b", false));
 2512|      1|        let server = McpServer::new(clients, false);
 2513|      1|        let res = server.get_resource_definitions();
 2514|      1|        assert!(!res.is_empty());
 2515|       |        // Should have qbittorrent://test/torrents etc.
 2516|      1|        let found = res.iter().any(|r| r["uri"] == "qbittorrent://test/torrents");
 2517|      1|        assert!(found);
 2518|      1|    }
 2519|       |}

